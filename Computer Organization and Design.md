好的，这是一个非常大的翻译任务。我会将这 100 页的 PDF 内容翻译成简体中文，并严格按照原有的页码进行组织。

对于技术术语，我会使用行业标准译法，对于代码、专有名词 (如 RISC-V, Intel Core i7) 和无法准确翻译的部分，我会保留原文。输出将以 Markdown 格式提供，您可以将其保存为 `.md` 文件。

以下是翻译后的内容：

-----

### **说明**

本文档是您提供的 `1-100.pdf` 文件的中文翻译版。

  * 内容从第 1 页到第 100 页，与原始 PDF 的页码一一对应。
  * 每个页面的内容都以 `--- PAGE X ---` 作为分隔符。
  * 技术术语已翻译为标准中文，专有名词、代码和部分缩写保留为英文，以确保准确性。
  * 图表和表格已根据原文重新构建，并翻译了标题和标签。

-----

\--- PAGE 1 ---

计算机
组织
与设计
RISC-V 版
硬件/软件接口
DAVID A. PATTERSON
JOHN L. HENNESSY
[徽标]
MK
MORGAN KAUFMANN

\--- PAGE 2 ---

对 《计算机组织与设计：硬件/软件接口》 的赞誉
“教科书的选择往往是一个令人沮丧的妥协过程——教学法、内容覆盖面、论述质量、严谨程度、成本。 《计算机组织与设计》 是一本罕见的、在各个方面都恰到好处的书，没有任何妥协。它不仅是首屈一指的计算机组织教科书，也是所有计算机科学教科书可以且应该成为的典范。”
—— Michael Goldweber, 泽维尔大学
“多年来，我一直在使用 《计算机组织与设计》，从第一版开始就是如此。这个新版本是在一本已经很经典的教材上的又一次杰出改进。从桌面计算到移动计算再到大数据的演进，带来了对嵌入式处理器（如 ARM）的新覆盖，以及关于软件和硬件如何交互以提高性能和云计算的新材料。所有这些都没有牺牲基础知识。”
—— Ed Harcourt, 圣劳伦斯大学
“致千禧一代： 《计算机组织与设计》 是你们应该放在（虚拟）书架上的计算机体系结构书籍。这本书既古老又新颖，因为它阐述了古老的原则——摩尔定律、抽象、加速常见情况、冗余、存储器层次结构、并行和流水线——但用当代的设计来阐释它们。”
—— Mark D. Hill, 威斯康星大学麦迪逊分校
“新版的 《计算机组织与设计》 与新兴的嵌入式和多核（GPU）系统的发展保持同步，在这些系统中，平板电脑和智能手机将/正在迅速成为我们的新桌面。本书承认这些变化，但继续为计算机组织与设计的基础知识提供丰富的基石，这对于为这类新设备和系统提供动力的硬件和软件设计者来说是必需的。”
—— Dave Kaeli, 东北大学
“《计算机组织与设计》 不仅仅是计算机体系结构的入门介绍。它为读者准备好迎接必要的变革，以满足移动系统和大数据处理日益增长的性能需求，而此时半导体规模缩小的困难正使所有系统都受到功耗限制。在这个计算新时代，硬件和软件必须协同设计，系统级架构与组件级优化同等重要。”
—— Christos Kozyrakis, 斯坦福大学
“Patterson 和 Hennessy 卓越地解决了不断变化的计算机硬件架构中的问题，重点强调了硬件和软件组件在不同抽象层次上的相互作用。通过在全书中将 I/O 和并行概念与硬件和软件中的各种机制穿插起来，新版本为后 PC 时代的计算机体系结构提供了一个出色的整体性呈现。这本书是硬件和软件专业人士在面临从平板电脑到云计算的能效和并行化挑战时的必备指南。”
—— Jae C. Oh, 雪城大学

\--- PAGE 3 ---

此页有意留空

\--- PAGE 4 ---

RISC V
版本
计算机组织与设计
硬件/软件接口

\--- PAGE 5 ---

David A. Patterson 是加州大学伯克利分校的 Pardee 计算机科学荣休教授，他于 1977 年从加州大学洛杉矶分校（UCLA）毕业后加入该校。他的教学工作获得了加州大学的杰出教学奖、ACM 的 Karlstrom 奖以及 IEEE 的 Mulligan 教育奖章和本科教学奖。
Patterson 因对 RISC 的贡献获得了 IEEE 技术成就奖和 ACM Eckert-Mauchly 奖，并因对 RAID 的贡献分享了 IEEE Johnson 信息存储奖。
他还与 John Hennessy 共同获得了 IEEE John von Neumann 奖章和 C\&C 奖。
与他的合著者一样，Patterson 是美国艺术与科学院、计算机历史博物馆、ACM 和 IEEE 的会士，并被选入美国国家工程院、美国国家科学院和硅谷工程名人堂。
他曾担任美国总统信息技术顾问委员会成员、伯克利 EECS 系计算机科学部主席、计算研究协会主席以及 ACM 主席。
这些履历为他赢得了来自 ACM、CRA 和 SIGARCH 的杰出服务奖。
在伯克利，Patterson 领导了 RISC I 的设计和实现，这可能是第一个 VLSI 精简指令集计算机，也是商业 SPARC 架构的基础。
他是廉价磁盘冗余阵列（RAID）项目的领导者之一，该项目促成了许多公司开发出可靠的存储系统。
他还参与了工作站网络（NOW）项目，该项目促成了互联网公司使用的集群技术，并随后发展为云计算。
这些项目赢得了四项 ACM 博士论文奖。他目前的研究项目是“算法-机器-人”以及“具有弹性和效率的可证明最优实现算法和专用器”。
AMP 实验室正在开发可扩展的机器学习算法、适合仓库规模计算机的编程模型和众包工具，以便从云端的大数据中快速获得有价值的见解。
ASPIRE 实验室利用深度的软硬件协同调优，为移动和机架计算系统实现尽可能高的性能和能效。
John L. Hennessy 是斯坦福大学电子工程和计算机科学教授，自 1977 年以来一直是该校教员，并在 2000 年至 2016 年期间担任该校第十任校长。
Hennessy 是 IEEE 和 ACM 的会士；美国国家工程院、美国国家科学院和美国哲学会的成员；
也是美国艺术与科学院的会士。
在他众多的奖项中，包括因其对 RISC 技术的贡献而获得的 2001 年 Eckert-Mauchly 奖，2001 年 Seymour Cray 计算机工程奖，以及与 David Patterson 共同获得的 2000 年 John von Neumann 奖。
他还获得了七个荣誉博士学位。
1981 年，他与少数研究生在斯坦福大学启动了 MIPS 项目。
1984 年完成该项目后，他从大学休假，共同创立了 MIPS 计算机系统公司（现为 MIPS Technologies），该公司开发了首批商业 RISC 微处理器之一。
截至 2006 年，已有超过 20 亿颗 MIPS 微处理器被用于从视频游戏、掌上电脑到激光打印机和网络交换机等各种设备中。
Hennessy 随后领导了 DASH（共享内存目录架构）项目，该项目原型化了第一个可扩展的缓存一致性多处理器；
许多关键思想已被现代多处理器所采用。
除了他的技术活动和大学职责外，他还继续与众多初创公司合作，担任早期顾问和投资者。

\--- PAGE 6 ---

RISCV 版
计算机组织与设计
硬件/软件接口
David A. Patterson
加州大学伯克利分校
John L. Hennessy
斯坦福大学
RISC-V 更新和贡献者
Andrew S. Waterman
SiFive, Inc.
Yunsup Lee
SiFive, Inc.
其他贡献者
Perry Alexander
堪萨斯大学
Peter J. Ashenden
Ashenden Designs Pty Ltd
Jason D. Bakos
南卡罗来纳大学
Javier Diaz Bruguera
圣地亚哥·德·孔波斯特拉大学
Jichuan Chang
谷歌
ELSEVIER
MK
Matthew Farrens
加州大学戴维斯分校
David Kaeli
东北大学
Nicole Kaiyan
阿德莱德大学
David Kirk
NVIDIA
Zachary Kurmas
格兰德谷州立大学
James R. Larus
EPFL 计算机与通信科学学院
MORGAN KAUFMANN 出版社
ELSEVIER 旗下品牌
elsevier.com
Kevin Lim
惠普
Eric Love
加州大学伯克利分校
John Nickolls
NVIDIA
John Y. Oliver
加州保利州立大学，圣路易斯奥比斯波
Milos Prvulovic
佐治亚理工学院
Partha Ranganathan
谷歌
Mark Smotherman
克莱姆森大学

\--- PAGE 7 ---

Morgan Kaufmann 是 Elsevier 的一个出版品牌
50 Hampshire Street, 5th Floor, Cambridge, MA 02139, United States
Copyright © 2018 Elsevier Inc. 版权所有。
未经出版商书面许可，不得以任何形式或任何手段（电子或机械，包括影印、录制或任何信息存储和检索系统）复制或传播本出版物的任何部分。
有关如何申请许可的详细信息、关于出版商许可政策的进一步信息以及我们与版权结算中心和版权许可代理等组织的安排，可在我们的网站上找到：[www.elsevier.com/permissions](https://www.elsevier.com/permissions)。
本书及其中的个人贡献受出版商的版权保护（除非另有说明）。
声明
本领域的知识和最佳实践在不断变化。
随着新的研究和经验拓宽我们的理解，研究方法、专业实践或医疗治疗可能会有必要的改变。
从业者和研究人员在评估和使用本文所述的任何信息、方法、化合物或实验时，必须始终依赖自己的经验和知识。
在使用这些信息或方法时，他们应注意自身和他人的安全，包括那些他们负有专业责任的各方。
在法律允许的最大范围内，出版商、作者、贡献者或编辑均不对因产品责任、疏忽或其他原因，或因使用或操作本文所含材料中的任何方法、产品、说明或思想而导致的任何人身伤害和/或财产损失承担任何责任。
RISC-V 和 RISC-V 徽标是 RISC-V 基金会管理的注册商标，经 RISC-V 基金会许可使用。
版权所有。
本出版物独立于 RISC-V 基金会，该基金会与出版商无附属关系，RISC-V 基金会未授权、赞助、认可或以其他方式批准本出版物。
所有与 ARM 技术相关的材料均经 ARM Limited 许可转载，且仅应用于教育目的。
文本中显示或引用的所有基于 ARM 的模型不得用于商业目的的复制或分发，购买本教科书在任何情况下均不得被解释为授予您或任何第三方使用任何其他 ARM 技术或专有技术的明示或暗示、禁止反言或其他形式的许可。
ARM 提供的材料版权归 ARM Limited（或其附属公司）所有。
英国国家图书馆出版物编目数据
本书的目录记录可从英国国家图书馆获取
美国国会图书馆出版物编目数据
本书的目录记录可从美国国会图书馆获取
ISBN: 978-0-12-812275-4
有关所有 Morgan Kaufmann 出版物的信息，请访问我们的网站 [https://www.elsevier.com/books-and-journals](https://www.elsevier.com/books-and-journals)
ELSEVIER
共同努力
在发展中国家
发展图书馆
Book Aid
[www.elsevier.com](https://www.elsevier.com) www.bookaid.org
出版人：Katey Birtcher
责任编辑：Steve Merken
开发编辑：Nate McFadden
制作项目经理：Lisa Jones
设计师：Victoria Pearson Esser
排版：MPS Limited, Chennai, India

\--- PAGE 8 ---

致 Linda，
过去、现在、将来，你永远是我一生的挚爱

\--- PAGE 9 ---

致谢
图 1.7, 1.8 由 iFixit ([www.ifixit.com](https://www.ifixit.com)) 提供。
图 1.9 由 Chipworks ([www.chipworks.com](https://www.chipworks.com)) 提供。
图 1.13 由 Intel 提供。
图 1.10.1, 1.10.2, 4.15.2 由明尼苏达大学图书馆查尔斯·巴贝奇研究所提供。
图 1.10.3, 4.15.1, 4.15.3, 5.12.3, 6.14.2 由 IBM 提供。
图 1.10.4 由 Cray Inc. 提供。
图 1.10.5 由 Apple Computer, Inc. 提供。
图 1.10.6 由计算机历史博物馆提供。
图 5.17.1, 5.17.2 由波士顿科学博物馆提供。
图 5.17.4 由 MIPS Technologies, Inc. 提供。
图 6.15.1 由 NASA 艾姆斯研究中心提供。

\--- PAGE 10 ---

目录
前言 XV
章节
1 计算机的抽象与技术 2
1.1 引言 3
1.2 计算机体系结构中的八个伟大思想 11
1.3 你的程序之下 13
1.4 揭开面纱 16
1.5 构建处理器和存储器的技术 24
1.6 性能 28
1.7 功耗墙 40
1.8 巨变：从单处理器到多处理器的转变 43
1.9 实例：基准测试 Intel Core i7 46
1.10 谬误与陷阱 49
1.11 结论 52
1.12 历史观点与延伸阅读 54
1.13 练习 54
2 指令：计算机的语言 60
2.1 引言 62
2.2 计算机硬件的操作 63
2.3 计算机硬件的操作数 67
2.4 有符号数和无符号数 74
2.5 在计算机中表示指令 81
2.6 逻辑运算 89
2.7 用于做决策的指令 92
2.8 在计算机硬件中支持过程 98
2.9 与人交流 108
2.10 用于宽立即数和地址的 RISC-V 寻址 113
2.11 并行性与指令：同步 121
2.12 翻译并启动一个程序 124
2.13 一个 C 语言排序示例的综合应用 133
2.14 数组与指针 141
2.15 高级材料：编译 C 和解释 Java 144

\--- PAGE 11 ---

X
目录
3
4
2.16 实例：MIPS 指令 145
2.17 实例：x86 指令 146
2.18 实例：RISC-V 指令集的其余部分 155
2.19 谬误与陷阱 157
2.20 结论 159
2.21 历史观点与延伸阅读 162
2.22 练习 162
计算机算术 172
3.1 引言 174
3.2 加法和减法 174
3.3 乘法 177
3.4 除法 183
3.5 浮点数 191
3.6 并行性与计算机算术：子字并行 216
3.7 实例：x86 中的流式 SIMD 扩展和高级向量扩展 217
3.8 加速：子字并行与矩阵乘法 218
3.9 谬误与陷阱 222
3.10 结论 225
3.11 历史观点与延伸阅读 227
3.12 练习 227
处理器 234
4.1 引言 236
4.2 逻辑设计约定 240
4.3 构建数据通路 243
4.4 一个简单的实现方案 251
4.5 流水线概述 262
4.6 流水线数据通路和控制 276
4.7 数据冒险：转发与暂停 294
4.8 控制冒险 307
4.9 异常 315
4.10 通过指令实现并行 321
4.11 实例：ARM Cortex-A53 和 Intel Core i7 流水线 334
4.12 加速：指令级并行与矩阵乘法 342
4.13 高级主题：使用硬件描述语言描述和建模流水线及更多流水线图示的数字设计入门 345
4.14 谬误与陷阱 345
4.15 结论 346
4.16 历史观点与延伸阅读 347
4.17 练习 347

\--- PAGE 12 ---

5
目录 xi
大且快：利用存储器层次结构 364
5.1 引言 366
5.2 存储技术 370
5.3 缓存基础 375
5.4 测量和改进缓存性能 390
5.5 可靠的存储器层次结构 410
5.6 虚拟机 416
5.7 虚拟内存 419
5.8 存储器层次结构的通用框架 443
5.9 使用有限状态机控制一个简单缓存 449
5.10 并行性与存储器层次结构：缓存一致性 454
5.11 并行性与存储器层次结构：廉价磁盘冗余阵列 458
5.12 高级材料：实现缓存控制器 459
5.13 实例：ARM Cortex-A53 和 Intel Core i7 存储器层次结构 459
5.14 实例：RISC-V 系统的其余部分和特殊指令 464
5.15 加速：缓存分块与矩阵乘法 465
5.16 谬误与陷阱 468
5.17 结论 472
5.18 历史观点与延伸阅读 473
5.19 练习 473
6 从客户端到云端的并行处理器 490
6.1 引言 492
6.2 创建并行处理程序的困难 494
6.3 SISD, MIMD, SIMD, SPMD, 和向量 499
6.4 硬件多线程 506
6.5 多核和其他共享内存多处理器 509
6.6 图形处理单元简介 514
6.7 集群、仓库规模计算机和其他消息传递多处理器 521
6.8 多处理器网络拓扑简介 526
6.9 与外部世界通信：集群网络 529
6.10 多处理器基准测试和性能模型 530
6.11 实例：Intel Core i7 960 和 NVIDIA Tesla GPU 的基准测试和屋顶线模型 540
6.12 加速：多处理器与矩阵乘法 545
6.13 谬误与陷阱 548
6.14 结论 550
6.15 历史观点与延伸阅读 553
6.16 练习 553

\--- PAGE 13 ---

xii
目录
附录
A 逻辑设计基础 A-2
A.1 引言 A-3
A.2 门、真值表和逻辑方程 A-4
A.3 组合逻辑 A-9
A.4 使用硬件描述语言 A-20
A.5 构建一个基本的算术逻辑单元 A-26
A.6 更快的加法：超前进位 A-37
A.7 时钟 A-47
A.8 存储元件：触发器、锁存器和寄存器 A-49
A.9 存储元件：SRAM 和 DRAM A-57
A.10 有限状态机 A-66
A.11 时序方法学 A-71
A.12 现场可编程器件 A-77
A.13 结论 A-78
A.14 练习 A-79
索引 I-1
在线
内容
图形与计算 GPU B-2
B.1 引言 B-3
B.2 GPU 系统架构 B-7
B.3 GPU 编程 B-12
B.4 多线程多处理器架构 B-25
B.5 并行存储系统 B-36
B.6 浮点算术 B-41
B.7 实例：NVIDIA GeForce 8800 B-46
B.8 实例：将应用映射到 GPU B-55
B.9 谬误与陷阱 B-72
B.10 结论 B-76
B.11 历史观点与延伸阅读 B-77
将控制映射到硬件 C-2
C.1 引言 C-3
C.2 实现组合控制单元 C-4
C.3 实现有限状态机控制 C-8
C.4 使用序列器实现下一状态函数 C-22
C.5 将微程序翻译成硬件 C-28
C.6 结论 C-32
C.7 练习 C-33

\--- PAGE 14 ---

目录
xiii
D 桌面、服务器和嵌入式计算机的 RISC 架构综述 D-2
D.1 引言 D-3
D.2 寻址模式和指令格式 D-5
D.3 指令：MIPS 核心子集 D-9
D.4 指令：桌面/服务器 RISC 的多媒体扩展 D-16
D.5 指令：嵌入式 RISC 的数字信号处理扩展 D-19
D.6 指令：MIPS 核心的通用扩展 D-20
D.7 MIPS-64 特有指令 D-25
D.8 Alpha 特有指令 D-27
D.9 SPARC v9 特有指令 D-29
D.10 PowerPC 特有指令 D-32
D.11 PA-RISC 2.0 特有指令 D-34
D.12 ARM 特有指令 D-36
D.13 Thumb 特有指令 D-38
D.14 SuperH 特有指令 D-39
D.15 M32R 特有指令 D-40
D.16 MIPS-16 特有指令 D-40
D.17 结论 D-43
术语表 G-1
延伸阅读 FR-1

\--- PAGE 15 ---

此页有意留空

\--- PAGE 16 ---

前言
我们能体验到的最美妙的事情是神秘。它是所有真正艺术和科学的源泉。
阿尔伯特·爱因斯坦, 《我的信仰》, 1930
关于本书
我们相信，计算机科学与工程的学习应该反映该领域的现状，并介绍那些正在塑造计算未来的原则。
我们也认为，计算领域的每个专业的读者都需要理解那些决定计算机系统能力、性能、能耗以及最终成功的组织范式。
现代计算机技术要求每个计算专业的专业人员都必须理解硬件和软件。
硬件和软件在不同层次上的交互也为理解计算的基础提供了一个框架。
无论你的主要兴趣是硬件还是软件，是计算机科学还是电子工程，计算机组织与设计的核心思想都是相同的。
因此，本书的重点是展示硬件和软件之间的关系，并关注那些构成当前计算机基础的概念。
最近从单处理器到多核微处理器的转变，证实了自第一版以来我们所持观点的正确性。
过去，程序员可以忽略这些建议，依赖计算机架构师、编译器编写者和芯片工程师使他们的程序运行得更快或更节能，而无需做任何改变，但那个时代已经结束了。
为了让程序运行得更快，它们必须变得并行化。
尽管许多研究人员的目标是让程序员能够不了解他们正在编程的硬件的底层并行特性，但要实现这一愿景还需要很多年。
我们的观点是，至少在未来十年，如果大多数程序员希望程序能在并行计算机上高效运行，他们将必须理解硬件/软件接口。
本书的读者包括那些在汇编语言或逻辑设计方面经验很少，但需要了解基本计算机组织的人，以及那些有汇编语言和/或逻辑设计背景，希望学习如何设计计算机或理解系统如何工作及其性能为何如此的读者。

\--- PAGE 17 ---

xvi
前言
关于另一本书
有些读者可能熟悉 《计算机体系结构：量化研究方法》，这本书通常被称为 Hennessy and Patterson。
(而本书又常被称为 Patterson and Hennessy。) 我们写前一本书的动机是，用坚实的工程基础和量化的成本/性能权衡来描述计算机体系结构的原理。
我们使用了一种结合实例和测量的方法，基于商业系统，以创造真实的设计体验。
我们的目标是证明计算机体系结构可以用量化的方法来学习，而不是描述性的方法。
它面向的是希望深入了解计算机的严肃计算专业人士。
本书的大多数读者并不打算成为计算机架构师。
然而，未来软件系统的性能和能效将受到软件设计者对系统中基本硬件技术理解程度的显著影响。
因此，编译器编写者、操作系统设计者、数据库程序员以及大多数其他软件工程师，都需要对本书中介绍的原理有坚实的掌握。
同样，硬件设计者必须清楚地理解他们的工作对软件应用程序的影响。
因此，我们知道这本书必须远不止是 《计算机体系结构》 材料的一个子集，并且为了匹配不同的读者群，材料被广泛地修订。
我们对结果非常满意，以至于后续版本的 《计算机体系结构》 也进行了修订，删除了大部分介绍性材料；
因此，与两本书的第一版相比，今天的重叠部分要少得多。
为什么本版选择 RISC-V？
指令集架构的选择对于一本计算机体系结构教科书的教学法显然至关重要。
我们不希望选择一个指令集，无论它多么流行，都需要为初学者描述不必要的繁琐特性。
理想情况下，你的第一个指令集应该是一个典范，就像你的初恋一样。令人惊讶的是，你对两者都怀有美好的回忆。
由于当时有很多选择，对于 《计算机体系结构：量化研究方法》 的第一版，我们发明了我们自己的 RISC 风格的指令集。
鉴于 MIPS 指令集的日益普及和其简洁的优雅，我们在本书的第一版和另一本书的后续版本中转向了 MIPS。
MIPS 对我们和我们的读者都很有帮助。
自我们做出那次转换以来已经过去了 20 年，虽然使用 MIPS 的芯片仍在以数十亿计的数量出货，但它们通常用于嵌入式设备中，指令集几乎是不可见的。
因此，一段时间以来，很难找到一台读者可以下载和运行 MIPS 程序的真实计算机。
好消息是，一个紧密遵循 RISC 原则的开放指令集最近首次亮相，并正在迅速获得追随者。
RISC-V，最初在加州大学伯克利分校开发，不仅清理了 MIPS 指令集的怪癖，

\--- PAGE 18 ---

前言
xvii
而且它为 2017 年的指令集应该是什么样子提供了一个简单、优雅、现代的范例。
此外，由于它不是专有的，因此有开源的 RISC-V 模拟器、编译器、调试器等可轻松获得，甚至还有用硬件描述语言编写的开源 RISC-V 实现。
此外，很快就会有低成本的硬件平台可以运行 RISC-V 程序。
读者不仅将从研究这些 RISC-V 设计中受益，他们还将能够修改它们并经历实现过程，以便理解他们假设的更改对性能、芯片尺寸和能耗的影响。
这对计算行业和教育来说都是一个激动人心的机会，因此在撰写本文时，已有 40 多家公司加入了 RISC-V 基金会。
这个赞助商名单几乎包括了除 ARM 和 Intel 之外的所有主要参与者，包括 AMD、谷歌、慧与（Hewlett Packard Enterprise）、IBM、微软、NVIDIA、甲骨文和高通。
正是由于这些原因，我们编写了本书的 RISC-V 版本，并且我们也将 《计算机体系结构：量化研究方法》 转换为 RISC-V。
鉴于 RISC-V 同时提供 32 位地址指令和 64 位地址指令，并且指令集基本相同，我们本可以在切换指令集的同时保持 32 位的地址大小。
我们的出版商对使用该书的教师进行了调查，发现 75% 的人要么偏爱更大的地址，要么持中立态度，所以我们将地址空间增加到 64 位，这在今天可能比 32 位更有意义。
RISC-V 版本与 MIPS 版本的唯一变化是与指令集变更相关的部分，这主要影响了第 2 章、第 3 章、第 5 章的虚拟内存部分以及第 6 章中简短的 VMIPS 示例。在第 4 章中，我们切换到了 RISC-V 指令，更改了几个图表，并添加了一些“阐述”部分，但更改比我们担心的要简单。
第 1 章和其余的附录几乎没有变化。
广泛的在线文档和 RISC-V 的庞大规模，使得为 MIPS 版本的附录 A（在 MIPS 第五版中为“汇编器、链接器和 SPIM 模拟器”）找到一个替代品变得困难。
相反，第 2、3 和 5 章包含了对我们书中详细介绍的核心 RISC-V 指令之外的数百条 RISC-V 指令的快速概述。
请注意，我们（还）没有说我们将永久切换到 RISC-V。
例如，除了这个新的 RISC-V 版本外，现在还有 ARMv8 和 MIPS 版本在售。
一种可能性是，本书的未来版本将需要所有版本，或者只需要一种。
我们到时再做决定。
目前，我们期待您对这项工作的反应和反馈。
第五版的改动
我们对《计算机组织与设计》第五版有六个主要目标：通过一个贯穿全书的例子来展示理解硬件的重要性；
使用早期介绍的页边图标来突出各个主题中的主要思想；

\--- PAGE 19 ---

xviii
前言
早期；更新示例以反映从 PC 时代到后 PC 时代的转变；
将 I/O 相关材料分散到全书中，而不是将其隔离在一个单独的章节中；
更新技术内容以反映自 2009 年第四版出版以来行业的变化；
以及将附录和可选章节放在网上，而不是附带 CD，以降低成本并使此版本作为电子书可行。
在详细讨论这些目标之前，让我们看看下一页的表格。
它展示了通过这些材料的硬件和软件路径。
第 1、4、5 和 6 章是两条路径上都有的，无论经验或重点如何。
第 1 章讨论了能源的重要性，以及它如何推动从单核到多核微处理器的转变，并介绍了计算机体系结构中的八个伟大思想。
对于硬件导向的读者来说，第 2 章很可能是复习材料，但对于软件导向的读者来说，它是必读的，特别是对于那些有兴趣学习更多关于编译器和面向对象编程语言的读者。
第 3 章是为有兴趣构建数据通路或学习更多关于浮点运算的读者准备的。
有些人会跳过第 3 章的部分内容，要么是因为他们不需要，要么是因为它们是复习。
然而，我们在本章中引入了矩阵乘法的贯穿示例，展示了子字并行如何提供四倍的改进，所以不要跳过 3.6 到 3.8 节。
第 4 章解释了流水线处理器。第 4.1、4.5 和 4.10 节提供了概述，第 4.12 节为软件焦点的读者提供了矩阵乘法的下一个性能提升。
然而，对于硬件焦点的读者来说，这一章是核心材料；
他们可能还想先阅读附录 A 中关于逻辑设计的内容，这取决于他们的背景。
最后一章，关于多核、多处理器和集群，大部分是新内容，所有人都应该阅读。
在这一版中，它被显著地重组，以使思想的流动更加自然，并包含了更多关于 GPU、仓库规模计算机以及作为集群关键的网络接口卡的硬件-软件接口的深度内容。

\--- PAGE 20 ---

下表：
| 章节或附录 | 软件焦点部分 | 硬件焦点 |
| :--- | :--- | :--- |
| **1. 计算机抽象与技术** | 1.1 至 1.11 | 相同 |
| | 1.12 (历史) | ♡ |
| **2. 指令：计算机的语言** | 2.1 至 2.14 | ♡ |
| | 2.15 (编译器与 Java) | |
| | 2.16 至 2.20 | ♡♡ |
| | 2.21 (历史) | |
| **D. RISC 指令集架构** | D.1 至 D.17 | 00 |
| **3. 计算机算术** | 3.1 至 3.5 | ♡♡ |
| | 3.6 至 3.8 (子字并行) | |
| | 3.9 至 3.10 (谬误) | |
| | 3.11 (历史) | |
| **A. 逻辑设计基础** | | A.1 至 A.13 |
| **4. 处理器** | 4.1 (概述) | ♡♡ |
| | 4.2 (逻辑约定) | |
| | 4.3 至 4.4 (简单实现) | |
| | 4.5 (流水线概述) | ♡♡ |
| | 4.6 (流水线数据通路) | |
| | 4.7 至 4.9 (冒险, 异常) | |
| | 4.10 至 4.12 (并行, 实例) | ♡ |
| | 4.13 (Verilog 流水线控制) | 0 |
| | 4.14 至 4.15 (谬误) | |
| | 4.16 (历史) | |
| **C. 将控制映射到硬件** | | C.1 至 C.6 |
| **5. 大且快：利用存储器层次结构** | 5.1 至 5.10 | ♡♡ |
| | 5.11 (廉价磁盘冗余阵列) | |
| | 5.12 (Verilog 缓存控制器) | 0 |
| | 5.13 至 5.17 | ♡ |
| | 5.18 (历史) | |
| **6. 从客户端到云的并行处理器** | 6.1 至 6.8 | ♡♡ |
| | 6.9 (网络) | |
| | 6.10 至 6.14 | ♡♡ |
| | 6.15 (历史) | |
| **B. 图形处理器单元** | B.1 至 B.13 | 00 |
| **图例** | | |
| ♡♡ | 仔细阅读 | |
| ♡ | 如果有时间则阅读 | |
| 0 | 供参考 | |
| 00 | | |

\--- PAGE 21 ---

xx
前言
第五版的六个目标中的第一个，是通过一个具体的例子来展示理解现代硬件对于获得良好性能和能效的重要性。
如上所述，我们在第 3 章从子字并行开始，将矩阵乘法性能提升 4 倍。我们在第 4 章通过循环展开将性能翻倍，以展示指令级并行的价值。
第 5 章通过使用分块优化缓存，再次将性能翻倍。
最后，第 6 章通过使用线程级并行，在 16 个处理器上展示了 14 倍的加速。
所有这四项优化总共只在我们最初的矩阵乘法示例中增加了 24 行 C 代码。
第二个目标是通过早期识别计算机体系结构的八个伟大思想，然后在书的其余部分指出它们出现的所有地方，来帮助读者区分主次。
我们使用（希望）易于记忆的页边图标，并在文本中突出显示相应的词语，以提醒读者这八个主题。
书中有近 100 处引用。没有一章的伟大思想示例少于七个，也没有一个思想被引用的次数少于五次。
通过并行、流水线和预测实现的性能是三个最受欢迎的伟大思想，紧随其后的是摩尔定律。
第 4 章“处理器”是示例最多的一章，这并不奇怪，因为它可能得到了计算机架构师最多的关注。
在每一章中都能找到的一个伟大思想是通过并行实现性能，考虑到并行在该领域和本书版本中的最新重点，这是一个令人愉快的发现。
第三个目标是通过本版的示例和材料，认识到计算领域从 PC 时代到后 PC 时代的代际变化。
因此，第 1 章深入探讨的是平板电脑的内部结构，而不是个人电脑，第 6 章描述了云的计算基础设施。
我们还重点介绍了 ARM，这是后 PC 时代个人移动设备的首选指令集，以及主导 PC 时代并（目前）主导云计算的 x86 指令集。
第四个目标是将 I/O 材料分散到全书中，而不是像我们在第四版中将并行性分散到所有章节那样，将其单独放在一章中。
因此，本版中的 I/O 材料可以在第 1.4、4.9、5.2、5.5、5.11 和 6.9 节中找到。
我们的想法是，如果 I/O 内容不被隔离到自己的章节中，读者（和教师）更有可能去覆盖它。
这是一个快速发展的领域，并且，正如我们新版本的惯例，一个重要的目标是更新技术内容。
贯穿全书的例子是 ARM Cortex A53 和 Intel Core i7，反映了我们的后 PC 时代。
其他亮点包括一个解释 GPU 独特术语的教程，更深入地介绍了构成云的仓库规模计算机，以及对万兆以太网卡的深入探讨。
为了保持主书的简短并与电子书兼容，我们将可选材料作为在线附录放置，而不是像以前的版本那样放在配套 CD 上。
最后，我们更新了书中所有的练习题。
虽然一些元素发生了变化，但我们保留了前几版中有用的书籍元素。
为了使本书更好地作为参考，我们仍然在页边空白处首次出现新术语时给出其定义。
名为

\--- PAGE 22 ---

前言
xxi
“理解程序性能”部分帮助读者理解其程序的性能以及如何改进它，就像“硬件/软件接口”部分帮助读者理解这个接口上的权衡一样。
“大局观”部分依然保留，以便读者在众多细节中看清全局。
“自测”部分帮助读者在第一次阅读时确认他们对材料的理解，答案在每章末尾提供。
这个版本仍然包含绿色的 RISC-V 参考卡，其灵感来自于 IBM System/360 的“绿卡”。
这张卡片已经更新，在编写 RISC-V 汇编语言程序时应该是一个方便的参考。
教师支持
我们收集了大量资料来帮助教师使用本书授课。
习题解答、书中图表、讲座幻灯片和其他材料可供在出版商处注册的教师使用。
此外，配套网站提供了免费 RISC-V 软件的链接。
请查看出版商网站了解更多信息：
[textbooks.elsevier.com/9780128122754](https://www.google.com/search?q=https://textbooks.elsevier.com/9780128122754)
结束语
如果你阅读下面的致谢部分，你会发现我们费了很大力气来纠正错误。
由于一本书会经过多次印刷，我们有机会进行更多的修正。
如果你发现任何残留的、顽固的错误，请通过电子邮件联系出版商，地址是 codRISCVbugs@mkp.com，或者使用版权页上找到的传统邮件地址。
这个版本是 Hennessy 和 Patterson 自 1989 年开始的长期合作中的第三次中断。管理世界顶尖大学之一的需求意味着 Hennessy 校长无法再投入大量精力来创作新版本。
剩下的作者再次感觉像是走钢丝却没有安全网。
因此，致谢部分提到的人们和伯克利的同事们在塑造本书内容方面发挥了更大的作用。
尽管如此，这一次，你将要阅读的新材料只能归咎于一位作者了。
致谢
本书的每一个版本，我们都非常幸运地得到了许多读者、审稿人和贡献者的帮助。
他们中的每一个人都帮助使这本书变得更好。
我们感谢 Khaled Benkrid 及其在 ARM Ltd. 的同事们，他们仔细审阅了与 ARM 相关的内容并提供了有益的反馈。
第 6 章被大规模修订，以至于我们对其思想和内容进行了单独的审查，并且我根据每位审稿人的反馈做了修改。
我要感谢斯坦福大学的 Christos Kozyrakis 建议使用网络

\--- PAGE 23 ---

xxii
前言
用于集群的接口来演示I/O的硬件-软件接口，并对组织本章其余部分提出建议；
感谢斯坦福大学的 Mario Flagsilk 提供了 NetFPGA NIC 的详细信息、图表和性能测量数据；
还要感谢以下人士为改进本章提出的建议：东北大学的 David Kaeli，惠普实验室的 Partha Ranganathan，威斯consin大学的 David Wood，以及我的伯克利同事 Siamak Faridani, Shoaib Kamil, Yunsup Lee, Zhangxi Tan, 和 Andrew Waterman。
特别感谢加州大学伯克利分校的 Rimas Avizenis，他开发了矩阵乘法的各种版本并提供了性能数据。
我在加州大学洛杉矶分校读研究生时曾与他的父亲共事，能在加州大学伯克利分校与 Rimas 合作，真是一种美好的对称。
我也想感谢我长期的合作伙伴，加州大学伯克利分校的 Randy Katz，他帮助我们发展了计算机体系结构中伟大思想的概念，这是我们共同对一门本科课程进行大规模修订的一部分。
我要感谢 David Kirk、John Nickolls 以及他们在 NVIDIA 的同事们（Michael Garland、John Montrym、Doug Voorhies、Lars Nyland、Erik Lindholm、Paulius Micikevicius、Massimiliano Fatica、Stuart Oberman 和 Vasily Volkov）撰写了第一篇关于 GPU 的深入附录。
我再次对最近被任命为 EPFL 计算机与通信科学学院院长的 Jim Larus 表示感谢，感谢他愿意贡献其在汇编语言编程方面的专业知识，并欢迎本书读者使用他开发和维护的模拟器。
我也非常感谢格兰德谷州立大学的 Zachary Kurmas，他更新并创作了新的练习题，这些练习题基于 Perry Alexander（堪萨斯大学）的原创；
Jason Bakos（南卡罗来纳大学）；Javier Bruguera（圣地亚哥·德·孔波斯特拉大学）；Matthew Farrens（加州大学戴维斯分校）；
David Kaeli（东北大学）；Nicole Kaiyan（阿德莱德大学）；John Oliver（加州理工州立大学圣路易斯奥比斯波分校）；Milos Prvulovic（佐治亚理工学院）；
Jichuan Chang（谷歌）；Jacob Leverich（斯坦福大学）；Kevin Lim（惠普）；以及 Partha Ranganathan（谷歌）。
另外还要感谢 Peter Ashenden 更新了讲座幻灯片。
我感谢许多回答了出版商调查、审阅了我们的提案并参加了焦点小组的教师们。
他们包括以下个人：焦点小组：Bruce Barton (萨福克郡社区学院), Jeff Braun (蒙大拿理工大学), Ed Gehringer (北卡罗来纳州立大学), Michael Goldweber (泽维尔大学), Ed Harcourt (圣劳伦斯大学), Mark Hill (威斯康星大学麦迪逊分校), Patrick Homer (亚利桑那大学), Norm Jouppi (惠普实验室), Dave Kaeli (东北大学), Christos Kozyrakis (斯坦福大学), Jae C. Oh (雪城大学), Lu Peng (路易斯安那州立大学), Milos Prvulovic (佐治亚理工学院), Partha Ranganathan (惠普实验室), David Wood (威斯康星大学), Craig Zilles (伊利诺伊大学厄巴纳-香槟分校)。
调查和评论：Mahmoud Abou-Nasr (韦恩州立大学), Perry Alexander (堪萨斯大学), Behnam Arad (萨克拉门托州立大学), Hakan Aydin (乔治梅森大学), Hussein Badr (纽约州立大学石溪分校), Mac Baker (弗吉尼亚军事学院), Ron Barnes (乔治梅森大学),

\--- PAGE 24 ---

前言
xxiii
Douglas Blough (佐治亚理工学院), Kevin Bolding (西雅图太平洋大学), Miodrag Bolic (渥太华大学), John Bonomo (威斯敏斯特学院), Jeff Braun (蒙大拿理工学院), Tom Briggs (希彭斯堡大学), Mike Bright (格罗夫城市学院), Scott Burgess (洪堡州立大学), Fazli Can (比尔肯特大学), Warren R. Carithers (罗切斯特理工学院), Bruce Carlton (梅萨社区学院), Nicholas Carter (伊利诺伊大学厄巴纳-香槟分校), Anthony Cocchi (纽约市立大学), Don Cooley (犹他州立大学), Gene Cooperman (东北大学), Robert D. Cupper (阿勒格尼学院), Amy Csizmar Dalal (卡尔顿学院), Daniel Dalle (舍布鲁克大学), Edward W. Davis (北卡罗来纳州立大学),
Nathaniel J. Davis (空军技术学院), Molisa Derk (俄克拉荷马城市大学), Andrea Di Blas (斯坦福大学), Derek Eager (萨斯喀彻温大学), Ata Elahi (南康涅狄格州立大学), Ernest Ferguson (西北密苏里州立大学), Rhonda Kay Gaede (阿拉巴马大学), Etienne M. Gagnon (魁北克大学蒙特利尔分校), Costa Gerousis (克里斯托弗·纽波特大学), Paul Gillard (纽芬兰纪念大学), Michael Goldweber (泽维尔大学), Georgia Grant (圣马特奥学院), Paul V. Gratz (德克萨斯 A\&M 大学), Merrill Hall (大师学院), Tyson Hall (南方复临大学), Ed Harcourt (圣
Lawrence University), Justin E. Harlow (南佛罗里达大学), Paul F. Hemler (汉普登-悉尼学院), Jayantha Herath (圣克劳德州立大学), Martin Herbordt (波士顿大学), Steve J. Hodges (卡布里洛学院), Kenneth Hopkinson (康奈尔大学), Bill Hsu (旧金山州立大学), Dalton Hunkins (圣文德大学), Baback Izadi (纽约州立大学新帕尔茨分校), Reza Jafari, Robert W. Johnson (科罗拉多技术大学), Bharat Joshi (北卡罗来纳大学夏洛特分校), Nagarajan Kandasamy (德雷塞尔大学), Rajiv Kapadia, Ryan Kastner (加州大学圣塔芭芭拉分校), E.J.
Kim (德州农工大学), Jihong Kim (首尔国立大学), Jim Kirk (联合大学), Geoffrey S. Knauth (莱科明学院), Manish M. Kochhal (韦恩州立大学), Suzan Koknar-Tezel (圣约瑟夫大学), Angkul Kongmunvattana (哥伦布州立大学), April Kontostathis (乌尔辛纳斯学院), Christos Kozyrakis (斯坦福大学), Danny Krizanc (卫斯理大学), Ashok Kumar, S. Kumar (德克萨斯大学), Zachary Kurmas (格兰德维利州立大学), Adrian Lauf (路易斯维尔大学), Robert N. Lea (休斯顿大学), Alvin Lebeck (杜克大学), Baoxin Li (亚利桑那州立大学), Li Liao (特拉华大学), Gary Livingston (马萨诸塞大学), Michael Lyle, Douglas W. Lynn (俄勒冈理工学院), Yashwant K
Malaiya (科罗拉多州立大学), Stephen Mann (滑铁卢大学), Bill Mark (德克萨斯大学奥斯汀分校), Ananda Mondal (克拉夫林大学), Alvin Moser (西雅图大学),
Walid Najjar (加州大学河滨分校), Vijaykrishnan Narayanan (宾夕法尼亚州立大学), Danial J. Neebel (洛拉斯学院), Victor Nelson (奥本大学), John Nestor (拉法耶特学院), Jae C. Oh (雪城大学), Joe Oldham (中央学院), Timour Paltashev, James Parkerson (阿肯色大学), Shaunak Pawagi (纽约州立大学石溪分校), Steve Pearce, Ted Pedersen

\--- PAGE 25 ---

xxiv
前言
（明尼苏达大学），Lu Peng（路易斯安那州立大学），Gregory D. Peterson（田纳西大学），William Pierce（胡德学院），Milos Prvulovic（佐治亚理工学院），Partha Ranganathan（惠普实验室），Dejan Raskovic（阿拉斯加大学费尔班克斯分校），Brad Richards（普吉特海湾大学），Roman Rozanov，Louis Rubinfield（维拉诺瓦大学），Md Abdus Salam（南方大学），Augustine Samba（肯特州立大学），Robert Schaefer（丹尼尔·韦伯斯特学院），Carolyn J. C. Schauble（科罗拉多州立大学），Keith Schubert（加州州立大学圣贝纳迪诺分校），William L. Schultz，Kelly Shaw（里士满大学），Shahram Shirani（麦克马斯特大学），Scott Sigman（德鲁里大学），Shai Simonson（斯通希尔学院），Bruce Smith，David Smith，Jeff W. Smith（佐治亚大学
雅典分校），Mark Smotherman（克莱姆森大学），Philip Snyder（约翰霍普金斯大学），Alex Sprintson（德州农工大学），Timothy D. Stanley（杨百翰大学），Dean Stevens（晨曦学院），Nozar Tabrizi（凯特灵大学），Yuval Tamir（加州大学洛杉矶分校），Alexander Taubin（波士顿大学），Will Thacker（温思罗普大学），Mithuna Thottethodi（普渡大学），Manghui Tu（南犹他大学），Dean Tullsen（加州大学圣地亚哥分校），Steve VanderLeest（加尔文学院），Christopher Vickery（纽约市立大学皇后学院），Rama Viswanathan（伯洛伊特学院），Ken Vollmar（密苏里州立大学），Guoping Wang（印第安纳-普渡大学），Patricia Wenner（巴克内尔大学），Kent Wilken（加州大学戴维斯分校），David Wolfe（古斯塔夫·阿道夫学院），David Wood（威斯康星大学麦迪逊分校），Ki
Hwan Yum（德克萨斯大学圣安东尼奥分校），Mohamed Zahran（纽约城市学院），Amr Zaky（圣塔克拉拉大学），Gerald D. Zarnett（瑞尔森大学），Nian Zhang（南达科他矿业与技术学院），Jiling Zhong（特洛伊大学），Huiyang Zhou（北卡罗来纳州立大学），Weiyu Zhu（伊利诺伊卫斯理大学）。
还要特别感谢 Mark Smotherman 多次校阅，找出技术和写作上的小瑕疵，显著提高了本版的质量。
我们要感谢 Morgan Kaufmann 的大家庭，在 Katey Birtcher、Steve Merken 和 Nate McFadden 的得力领导下，同意再次出版这本书：没有他们，我肯定无法完成这本书。
我们还要感谢 Lisa Jones，她管理了这本书的制作过程，以及 Victoria Pearson Esser，她做了封面设计。
封面巧妙地将本版的后 PC 时代内容与第一版的封面联系起来。
最后，我非常感谢 Yunsup Lee 和 Andrew Waterman 在创办一家创业公司的业余时间里承担了这次向 RISC-V 的转换工作。
也要向 Eric Love 致敬，他在完成博士学业的同时，为本版制作了 RISC-V 版本的练习题。
我们都很兴奋地想看看 RISC-V 在学术界及其他领域会发生什么。
我们在这里提到的近 150 人的贡献，帮助使这个新版本成为我希望是迄今为止我们最好的一本书。
祝您阅读愉快！
David A. Patterson

\--- PAGE 26 ---

此页有意留空

\--- PAGE 27 ---

1
计算机
抽象与
技术

| | |
| :--- | :--- |
| 1.1 | 引言 3 |
| 1.2 | 计算机体系结构中的八个伟大思想 11 |
| 1.3 | 你的程序之下 13 |
| 1.4 | 揭开面纱 16 |
| 1.5 | 构建处理器和存储器的技术 24 |

文明的进步，
在于扩展了
那些我们无需思考
即可执行的
重要操作的数量。
阿尔弗雷德·诺斯·怀特海,
《数学导论》, 1911
计算机组织与设计。 DOI: [http://dx.doi.org/10.1016/8978-0-12-812275-4.00001-4](http://dx.doi.org/10.1016/8978-0-12-812275-4.00001-4)
2018 Elsevier Inc. 版权所有

\--- PAGE 28 ---

| | |
| :--- | :--- |
| 1.6 | 性能 28 |
| 1.7 | 功耗墙 40 |
| 1.8 | 巨变：从单处理器到多处理器的转变 43 |
| 1.9 | 实例：基准测试 Intel Core i7 46 |
| 1.10 | 谬误与陷阱 49 |
| 1.11 | 结论 52 |
| 1.12 | 历史观点与延伸阅读 54 |
| 1.13 | 练习 54 |

**1.1**
**引言**
欢迎阅读本书！我们很高兴能有这个机会，向您传达计算机系统世界的激动人心之处。
这不是一个枯燥乏味的领域，在这里，进步不是缓慢的，新思想也不会因被忽视而萎缩。不！
计算机是充满活力的信息技术产业的产物，该产业的各个方面几乎占了美国国民生产总值的 10%，其经济在一定程度上已经依赖于摩尔定律所承诺的信息技术的快速改进。
这个非同寻常的行业以惊人的速度拥抱创新。在过去的 30 年里，有许多新计算机的推出似乎彻底改变了计算行业；
这些革命之所以戛然而止，只是因为别人制造出了更好的计算机。
这场创新竞赛自 20 世纪 40 年代末电子计算诞生以来，带来了前所未有的进步。
举例来说，如果交通运输业能跟上计算机产业的步伐，今天我们从纽约到伦敦只需一秒钟，花费一便士。
花点时间思考一下这样的改进将如何改变社会——生活在塔希提岛，却在旧金山工作；去莫斯科欣赏一晚波修瓦芭蕾舞团的演出——你就能体会到这种变化所带来的影响。

\--- PAGE 29 ---

4
第 1 章 计算机抽象与技术
计算机为人类文明带来了第三次革命，信息革命与农业革命和工业革命并驾齐驱。
由此带来的人类智力力量和影响范围的倍增，自然深刻地影响了我们的日常生活，并改变了探寻新知识的方式。
现在出现了一个新的科学研究领域，计算科学家与理论和实验科学家一起，在天文学、生物学、化学和物理学等领域探索新的前沿。
计算机革命仍在继续。每当计算成本再降低一个数量级，计算机的应用机会就会成倍增加。
过去在经济上不可行的应用突然变得实用。在最近的过去，以下应用都曾是“计算机科幻小说”。
■ 汽车中的计算机：直到 20 世纪 80 年代初微处理器在价格和性能上有了显著提高，用计算机控制汽车还是荒谬的。
如今，计算机通过发动机控制减少污染、提高燃油效率，并通过盲点警告、车道偏离警告、移动物体检测以及在碰撞中充气保护乘客的安全气囊来提高安全性。
■ 手机：谁曾梦想过计算机系统的进步会导致地球上一半以上的人拥有移动电话，使得人与人之间几乎可以在世界任何地方进行通信？
■ 人类基因组计划：绘制和分析人类 DNA 序列的计算机设备成本曾高达数亿美元。
如果计算机成本高出 10 到 100 倍（就像 15 到 25 年前那样），任何人都不太可能考虑这个项目。
而且，成本还在持续下降；你很快就能获得自己的基因组，从而实现为你量身定制的医疗保健。
■ 万维网：本书第一版出版时还不存在，网络已经改变了我们的社会。
对许多人来说，网络已经取代了图书馆和报纸。
搜索引擎：随着网络内容的规模和价值不断增长，找到相关信息变得越来越重要。
如今，许多人在生活中如此依赖搜索引擎，以至于没有它们将是一种 hardship（困难）。
显然，这项技术的进步现在几乎影响了我们社会的方方面面。
硬件的进步让程序员能够创造出非常有用的软件，这也解释了为什么计算机无处不在。
今天的科幻小说预示着明天的杀手级应用：能够增强现实的眼镜、无现金社会以及能够自动驾驶的汽车已经箭在弦上。

\--- PAGE 30 ---

1.1 引言
5
计算应用的传统类别及其特点
尽管从智能家电、手机到最大的超级计算机，都使用了一套通用的硬件技术（见 1.4 和 1.5 节），但这些不同的应用有不同的设计要求，并以不同的方式使用核心硬件技术。
广义上讲，计算机用于三种不同类别的应用。
个人计算机（PC）可能是最广为人知的计算形式，本书的读者很可能已经广泛使用。
个人计算机强调以低成本为单个用户提供良好性能，并且通常执行第三方软件。
这类计算驱动了许多计算技术的发展，而这仅仅是 35 年前的事情！
服务器是曾经更大计算机的现代形式，通常只能通过网络访问。
服务器旨在承载巨大的工作负载，这些工作负载可能由单个复杂的应用程序（通常是科学或工程应用程序）组成，也可能处理许多小作业，例如构建大型 Web 服务器时会发生的情况。
这些应用程序通常基于来自其他来源的软件（例如数据库或模拟系统），但通常会为特定功能进行修改或定制。
服务器基于与台式计算机相同的基本技术构建，但提供更大的计算、存储和输入/输出能力。
总的来说，服务器也更强调可靠性，因为一次崩溃通常比在单用户个人电脑上造成的损失更大。
服务器在成本和能力上跨度最广。在低端，一台服务器可能只是一台没有屏幕或键盘的台式电脑，成本为一千美元。
这些低端服务器通常用于文件存储、小型企业应用或简单的网页服务。
在另一极端是超级计算机，目前由数万个处理器和数太字节的内存组成，成本高达数千万到数亿美元。
超级计算机通常用于高端科学和工程计算，如天气预报、石油勘探、蛋白质结构测定和其他大规模问题。
尽管这类超级计算机代表了计算能力的顶峰，但它们在服务器中只占相对较小的比例，因此在总收入方面，在整个计算机市场中所占的比例也相应地微乎其微。
嵌入式计算机是最大的一类计算机，应用和性能范围最广。
嵌入式计算机包括您汽车中的微处理器、电视机中的计算机，以及控制现代飞机或货船的处理器网络。
嵌入式计算系统旨在运行一个应用程序或一组相关的应用程序，这些应用程序通常与硬件集成并作为单个系统交付；
因此，尽管嵌入式计算机数量众多，但大多数用户从未真正意识到他们正在使用计算机！
**个人计算机 (PC)** 一种供个人使用的计算机，通常包含图形显示器、键盘和鼠标。
**服务器** 一种用于为多个用户运行较大型程序的计算机，通常是同时运行，并且通常只能通过网络访问。
**超级计算机** 一类具有最高性能和成本的计算机；它们被配置为服务器，通常成本在数千万到数亿美元之间。
**太字节 (TB)** 最初是 1,099,511,627,776 ($2^{40}$) 字节，尽管通信和二级存储系统开发者开始使用这个术语来表示 1,000,000,000,000 ($10^{12}$) 字节。
为了减少混淆，我们现在使用术语 tebibyte (TiB) 表示 $2^{40}$ 字节，定义 terabyte (TB) 表示 $10^{12}$ 字节。
图 1.1 显示了十进制和二进制数值和名称的全范围。
**嵌入式计算机** 一种内置于其他设备中的计算机，用于运行一个预定的应用程序或软件集合。

\--- PAGE 31 ---

好的，完全没问题。我们采用分段翻译的方式，每次 20 页，完成后我会停下并询问您是否继续。这样可以确保您有足够的时间处理内容，避免浏览器卡顿或内容丢失。

这是第一部分，包含 **第 32 页到第 51 页** 的翻译内容。

-----

\--- PAGE 32 ---

个人电脑的是个人移动设备 (PMD)。PMD 使用电池供电，通过无线方式连接到互联网，通常花费数百美元，并且像个人电脑一样，用户可以下载软件（“应用程序”）来运行。
与个人电脑不同，它们不再有键盘和鼠标，更可能依赖于触摸屏甚至语音输入。
今天的 PMD 是智能手机或平板电脑，但明天可能包括电子眼镜。
图 1.2 显示了平板电脑和智能手机随时间的快速增长，与个人电脑和传统手机的增长情况形成对比。
智能手机代表了手机行业的近期增长，并在 2011 年超过了个人电脑。平板电脑是增长最快的类别，在 2011 年至 2012 年间几乎翻了一番。近期的个人电脑和传统手机类别相对平稳或呈下降趋势。
取代传统服务器的是云计算，它依赖于现在被称为仓库级计算机 (WSC) 的巨型数据中心。
像亚马逊和谷歌这样的公司建造这些包含 10 万台服务器的 WSC，然后让公司租用其中的一部分，这样他们就可以向 PMD 提供软件服务，而不必自己建造 WSC。
确实，通过云部署的软件即服务 (SaaS) 正在彻底改变软件行业，就像 PMD 和 WSC 正在彻底改变硬件行业一样。
今天的软件开发者通常会有一部分应用程序在 PMD 上运行，另一部分在云端运行。
**个人移动设备 (PMD)** 是小型无线设备，用于连接互联网；它们依靠电池供电，软件通过下载应用程序安装。常规示例是智能手机和平板电脑。
**云计算** 指的是通过互联网提供服务的大型服务器集合；一些提供商以公用事业的形式动态出租数量不等的服务器。
**软件即服务 (SaaS)** 将软件和数据作为服务通过互联网交付，通常通过在本地客户端设备上运行的轻量级程序（如浏览器）进行，而不是必须安装并完全在该设备上运行的二进制代码。示例包括网页搜索和社交网络。

**图 1.2** 反映后 PC 时代的平板电脑和智能手机与个人电脑和传统手机的年产量对比。智能手机代表了手机行业的近期增长，并在 2011 年超过了个人电脑。平板电脑是增长最快的类别，在 2011 年到 2012 年间几乎翻了一番。近期的 PC 和传统手机类别相对平稳或呈下降趋势。

**本书你能学到什么**
成功的程序员总是关心他们程序的性能，因为快速向用户提供结果对于创造受欢迎的软件至关重要。
在 20 世纪 60 年代和 70 年代，计算机性能的一个主要限制是计算机内存的大小。
因此，程序员通常遵循一个简单的信条：最小化内存空间以使程序快速运行。在

\--- PAGE 33 ---

8
第 1 章 计算机抽象与技术
**多核微处理器** 一种在单个集成电路中包含多个处理器（“核”）的微处理器。
过去十年，计算机设计和存储技术的进步大大降低了小程序内存在大多数应用中的重要性，除了嵌入式计算系统中的那些应用。
对性能感兴趣的程序员现在需要理解那些已经取代了 20 世纪 60 年代简单内存模型的问题：处理器的并行性和存储器的层次性。
我们将在第 3 到第 6 章中通过展示如何将一个 C 程序的性能提高 200 倍来证明这种理解的重要性。此外，正如我们在 1.7 节中所解释的，今天的程序员需要担心他们的程序在 PMD 或云端运行时的能效，这也需要理解你的代码之下有什么。
因此，寻求构建有竞争力的软件版本的程序员将需要增加他们对计算机组织的知识。
我们很荣幸有机会解释这台革命性机器的内部构造，揭示您程序之下的软件和您计算机外壳之下的硬件。
当您完成本书时，我们相信您将能够回答以下问题：
■ 用高级语言（如 C 或 Java）编写的程序如何被翻译成硬件的语言，硬件又如何执行最终的程序？
理解这些概念构成了理解影响程序性能的硬件和软件方面的基础。
■ 软件和硬件之间的接口是什么，软件如何指令硬件执行所需的功能？
这些概念对于理解如何编写多种软件至关重要。
■ 什么决定了程序的性能，程序员如何提高性能？
正如我们将看到的，这取决于原始程序、将该程序翻译成计算机语言的软件，以及硬件执行该程序的有效性。
■ 硬件设计者可以使用哪些技术来提高性能？
本书将介绍现代计算机设计的基本概念。
感兴趣的读者将在我们的高级书籍《计算机体系结构：量化研究方法》中找到更多关于这个主题的材料。
■ 硬件设计者可以采用哪些技术来提高能效？
程序员可以做些什么来帮助或阻碍能效？
■ 最近从顺序处理转向并行处理的原因和后果是什么？
本书给出了动机，描述了当前支持并行的硬件机制，并概述了新一代的“多核”微处理器（见第 6 章）。
■ 自 1951 年第一台商用计算机问世以来，计算机架构师们提出了哪些奠定现代计算基础的伟大思想？

\--- PAGE 34 ---

1.1 引言
如果不理解这些问题的答案，那么在现代计算机上提高程序性能，或者评估哪些特性可能使一台计算机比另一台更适合某个特定应用，将是一个反复试验的复杂过程，而不是一个由洞察力和分析驱动的科学过程。
这第一章为本书的其余部分奠定了基础。
它介绍了基本的思想和定义，将软件和硬件的主要组件置于适当的位置，展示了如何评估性能和能耗，介绍了集成电路（推动计算机革命的技术），并解释了向多核的转变。
在本章和后续章节中，您可能会看到许多新词，或者您可能听说过但不确定其含义的词。
不要惊慌！是的，描述现代计算机时会使用很多专业术语，但这些术语实际上很有帮助，因为它使我们能够精确地描述一个功能或能力。
此外，计算机设计者（包括您的作者）喜欢使用首字母缩略词，一旦您知道这些字母代表什么，就很容易理解了！
为了帮助您记忆和定位术语，我们已在每个术语首次出现在文本中时，在页边空白处给出了高亮定义。
经过一小段时间的术语学习，您将能够流利运用，并且当您正确使用如 BIOS、CPU、DIMM、DRAM、PCIe、SATA 等缩略词时，您的朋友会印象深刻。
为了强调用于运行程序的软件和硬件系统将如何影响性能，我们在全书中使用了“理解程序性能”这个特殊部分来总结有关程序性能的重要见解。
第一个见解如下。
**首字母缩略词 (acronym)** 由一串单词的首字母构成的词。例如：RAM 是 Random Access Memory 的缩写，CPU 是 Central Processing Unit 的缩写。
9

> **理解程序性能**
>
> 程序的性能取决于程序中使用的算法的有效性、用于创建和将程序翻译成机器指令的软件系统，以及计算机执行这些指令的有效性（其中可能包括输入/输出 (I/O) 操作）的组合。
>
> **性能**
>
> 下表总结了硬件和软件如何影响性能。
>
> | 硬件或软件组件 | 该组件如何影响性能 | 在哪里讨论？ |
> | :--- | :--- | :--- |
> | 算法 | 决定了源级语句的数量和执行的 I/O 操作的数量 | 其他书籍！ |
> | 编程语言、编译器和体系结构 | 决定了每个源级语句对应的计算机指令数量 | 第 2 章和第 3 章 |
> | 处理器和存储系统 | 决定了指令能以多快的速度被执行 | 第 4、5、6 章 |
> | I/O 系统（硬件和操作系统） | 决定了 I/O 操作能以多快的速度被执行 | 第 4、5、6 章 |

\--- PAGE 35 ---

10
第 1 章 计算机抽象与技术
为了展示本书中思想的影响，如上所述，我们在一系列章节中改进了一个 C 程序（该程序将矩阵乘以向量）的性能。
每一步都利用了对现代微处理器底层硬件实际工作方式的理解，将性能提高了 200 倍！
■ 在数据级并行类别中，我们在第 3 章使用 C 语言的内建函数 (intrinsics) 实现子字并行，将性能提高了 3.8 倍。
■ 在指令级并行类别中，我们在第 4 章使用循环展开来利用多指令发射和乱序执行硬件，将性能再提高 2.3 倍。
■ 在存储器层次结构优化类别中，我们在第 5 章使用缓存分块，将大矩阵的性能再提高 2.0 到 2.5 倍。
■ 在线程级并行类别中，我们在第 6 章使用 OpenMP 中的并行 for 循环来利用多核硬件，将性能再提高 4 到 14 倍。

> **自测**
>
> 自测部分旨在帮助读者评估他们是否理解了章节中介绍的主要概念，以及这些概念的含义。
> 一些自测问题有简单的答案；另一些则供小组讨论。
> 具体问题的答案可以在章节末尾找到。
> 自测问题只出现在节的末尾，如果您确定已经理解了材料，可以轻松跳过它们。

1.  每年销售的嵌入式处理器数量远远超过个人电脑甚至后PC处理器的数量。
    你能根据自己的经验证实或否认这一观点吗？
    试着数一数你家里的嵌入式处理器数量。
    它与你家里的常规计算机数量相比如何？
2.  如前所述，软件和硬件都会影响程序的性能。
    你能想到在以下哪些情况下，寻找性能瓶颈是正确的方向吗？
    ■ 所选择的算法
    ■ 编程语言或编译器
    ■ 操作系统
    ■ 处理器
    ■ I/O 系统和设备

\--- PAGE 36 ---

1.2 计算机体系结构中的八个伟大思想
11
**1.2**
**计算机体系结构中的八个伟大思想**
我们现在介绍计算机架构师在过去 60 年的计算机设计中发明的八个伟大思想。
这些思想如此强大，以至于在第一个使用它们的计算机出现很久之后，它们仍然存在，后来的架构师通过模仿前辈来表达他们的敬佩。
这些伟大思想是我们将在本章及后续章节中随着示例的出现而贯穿的主题。
为了指出它们的影响，在本节中，我们介绍代表这些伟大思想的图标和高亮术语，并用它们来标识书中近 100 个使用了这些伟大思想的章节。
**为摩尔定律而设计**
对计算机设计者来说，唯一不变的就是快速变化，这在很大程度上是由摩尔定律驱动的。
该定律指出，集成电路的资源每 18-24 个月翻一番。
摩尔定律源于 1965 年英特尔创始人之一戈登·摩尔对集成电路容量增长的预测。
由于计算机设计可能需要数年时间，从项目开始到结束，每个芯片可用的资源很容易翻倍或翻四倍。
就像打飞碟的射手一样，计算机架构师必须预测设计完成时技术将发展到何种程度，而不是为开始时的技术水平而设计。
我们用一个“右上角箭头”的摩尔定律图来表示为快速变化而设计。
**摩尔定律**
**使用抽象简化设计**
计算机架构师和程序员都必须发明技术来提高自己的生产力，否则设计时间将随着摩尔定律带来的资源增长而急剧延长。
硬件和软件的一个主要生产力技术是使用抽象来在不同层次的表示上描述设计；
较低层次的细节被隐藏起来，以便在较高层次上提供一个更简单的模型。
我们将使用抽象画图标来表示这第二个伟大的思想。
**抽象**
**加速常见情况**
加速常见情况往往比优化罕见情况更能提升性能。
讽刺的是，常见情况通常比罕见情况更简单，因此通常更容易增强。
这个常识性建议意味着你知道什么是常见情况，而这只有通过仔细的实验和测量才可能做到（见 1.6 节）。
我们用一辆跑车作为加速常见情况的图标，因为最常见的出行只有一两个乘客，而且制造一辆快的跑车肯定比制造一辆快的面包车容易！
**加速常见情况**

\--- PAGE 37 ---

12
第 1 章 计算机抽象与技术
**通过并行提升性能**
自计算诞生之日起，计算机架构师就提出了通过并行计算操作来获得更高性能的设计。
我们将在本书中看到许多并行的例子。我们用一架飞机的多个喷气发动机作为我们并行性能的图标。
**并行**
**通过流水线提升性能**
一种特殊的并行模式在计算机体系结构中非常普遍，以至于它有自己的名字：流水线。
例如，在消防车出现之前，一个“水桶队”会响应火灾，许多西部片中都展示了这种场景，以应对反派的卑鄙行径。
镇民们排成一条人链，将水源运到火场，因为他们通过人链传递水桶比个人来回跑要快得多。
我们的流水线图标是一系列管道，每一段代表流水线的一个阶段。
**流水线**
**通过预测提升性能**
俗话说，请求原谅比请求许可更好，下一个伟大的思想是预测。
在某些情况下，猜测并开始工作可能比等到确定后再做要快，前提是纠正错误预测的机制不太昂贵，而且你的预测相对准确。
我们用水晶球作为我们的预测图标。
**预测**
**存储器层次结构**
程序员希望内存既快、又大、又便宜，因为内存速度常常影响性能，容量限制了可以解决的问题的大小，而今天内存的成本往往是计算机成本的大部分。
架构师们发现，他们可以通过存储器层次结构来解决这些相互矛盾的需求，层次结构的顶层是速度最快、容量最小、每比特成本最高的内存，而底层则是速度最慢、容量最大、每比特成本最低的内存。
正如我们将在第 5 章中看到的，缓存给程序员一种错觉，即主存几乎和层次结构顶层一样快，并且几乎和层次结构底层一样大和便宜。
我们用一个分层的三角形图标来表示存储器层次结构。
形状表示速度、成本和大小：越靠近顶部，内存每比特的速度越快、越昂贵；
层的底部越宽，内存越大。
**层次结构**
**通过冗余实现可靠性**
计算机不仅需要快，还需要可靠。
由于任何物理设备都可能发生故障，我们通过包含冗余组件来使系统可靠，这些组件可以在故障发生时接管，并帮助检测故障。
我们用拖挂式卡车作为我们的图标，因为它后轴两侧的双轮胎使卡车即使在一个轮胎爆胎时也能继续行驶。
（据推测，卡车司机会立即前往维修设施修复爆胎，从而恢复冗余性！）
**可靠性**

\--- PAGE 38 ---

1.3 你的程序之下
13
**1.3 你的程序之下**
一个典型的应用程序，如文字处理器或大型数据库系统，可能包含数百万行代码，并依赖于复杂的软件库，这些库为应用程序提供复杂功能的支持。
正如我们将看到的，计算机中的硬件只能执行极其简单的低级指令。
从复杂的应用程序到原始指令，需要经过几层软件，这些软件将高级操作解释或翻译成简单的计算机指令，这是抽象这个伟大思想的一个例子。
在巴黎，当我对他们说法语时，他们只是盯着我看；我始终没能让那些白痴明白他们自己的语言。——马克·吐温，《傻子国外旅行记》，1869
**抽象**
**系统软件** 提供通用服务的软件，包括操作系统、编译器、加载器和汇编器。
**操作系统** 管理计算机资源以利于在该计算机上运行的程序的监控程序。
图 1.3 显示了这些软件层主要以分层方式组织，应用程序是最外层，各种系统软件位于硬件和应用程序软件之间。
系统软件有很多类型，但如今每台计算机系统中都有两种核心的系统软件：操作系统和编译器。
操作系统在用户程序和硬件之间进行接口，并提供各种服务和监控功能。
其中最重要的功能包括：
■ 处理基本的输入和输出操作
■ 分配存储和内存
■ 为多个同时使用计算机的应用程序提供受保护的共享
目前使用的操作系统例子有 Linux、iOS 和 Windows。

**图 1.3** 硬件和软件作为分层结构的简化视图，显示为同心圆，硬件在中心，应用软件在最外层。在复杂的应用中，通常也有多层应用软件。例如，数据库系统可能运行在托管应用程序的系统软件之上，而该应用程序又运行在数据库之上。

\--- PAGE 39 ---

14
第 1 章 计算机抽象与技术
**编译器** 将高级语言语句翻译成汇编语言语句的程序。
**二进制位** 也称为 bit。构成信息的两个数字（0 或 1）之一。
**指令** 计算机硬件理解并服从的命令。
**汇编器** 将指令的符号版本翻译成二进制版本的程序。
**汇编语言** 机器指令的符号表示。
**机器语言** 机器指令的二进制表示。
编译器执行另一项至关重要的功能：将用高级语言（如 C、C++、Java 或 Visual Basic）编写的程序翻译成硬件可以执行的指令。
鉴于现代编程语言的复杂性和硬件执行指令的简单性，从高级语言程序到硬件指令的翻译是复杂的。
我们在这里对这个过程做一个简要的概述，然后在第 2 章进行更深入的探讨。
**从高级语言到硬件语言**
要直接与电子硬件对话，你需要发送电信号。
计算机最容易理解的信号是“开”和“关”，所以计算机的字母表只有两个字母。
正如 26 个英文字母并不限制可以写多少东西一样，计算机字母表的两个字母也并不限制计算机能做什么。
这两个字母的两个符号是数字 0 和 1，我们通常认为计算机语言是二进制数。
我们把每个“字母”称为一个二进制位或 bit。
计算机是我们命令的奴隶，这些命令被称为指令。指令，也就是计算机理解和服从的位的集合，可以被看作是数字。例如，位序列
1001010100101110
告诉一台计算机将两个数相加。第 2 章解释了我们为什么用数字来表示指令和数据；
我们不想抢了那一章的风头，但用数字同时表示指令和数据是计算的基础。
最初的程序员用二进制数与计算机交流，但这太繁琐了，所以他们很快发明了更接近人类思维方式的新符号。
起初，这些符号是手动翻译成二进制的，但这个过程仍然很累人。
利用计算机帮助编程计算机，先驱们发明了软件，用于从符号表示法翻译成二进制。
这些程序中的第一个被命名为汇编器。这个程序将指令的符号版本翻译成二进制版本。
例如，程序员会写
`add A, B`
汇编器会把这个符号翻译成
`1001010100101110`
这条指令告诉计算机将两个数 A 和 B 相加。为这种符号语言创造的名字，至今仍在使用，就是汇编语言。
相比之下，机器能理解的二进制语言就是机器语言。
尽管汇编语言是一个巨大的进步，但它仍然远非科学家可能希望用来模拟流体流动或会计师可能用来平衡账目的表示法。
汇编语言要求程序员为计算机将遵循的每一条指令写一行代码，迫使程序员像计算机一样思考。

\--- PAGE 40 ---

1.3 你的程序之下
15
认识到一个程序可以被编写来将一种更强大的语言翻译成计算机指令，是计算早期的一大突破。
今天的程序员要感谢高级编程语言和编译器的发明，这些编译器将这类语言的程序翻译成指令，从而提高了他们的生产力并保护了他们的理智。
图 1.4 展示了这些程序和语言之间的关系，这是抽象力量的更多例子。
**高级编程语言** 一种可移植的语言，如 C、C++、Java 或 Visual Basic，由单词和代数符号组成，可以由编译器翻译成汇编语言。
**抽象**

**图 1.4** C 程序被编译成汇编语言，然后汇编成二进制机器语言。虽然从高级语言到二进制机器语言的翻译分两步显示，但一些编译器会省去中间环节，直接生成二进制机器语言。这些语言和程序将在第2章更详细地讨论。

\--- PAGE 41 ---

16
第 1 章 计算机抽象与技术
编译器使程序员能够编写这样的高级语言表达式：
`A + B`
编译器会将其编译成这样的汇编语言语句：
`add A, B`
如上所示，汇编器会将这条语句翻译成二进制指令，告诉计算机将两个数 A 和 B 相加。
高级编程语言提供了几个重要的好处。首先，它们允许程序员用更自然的语言思考，使用英语单词和代数符号，使得程序看起来更像文本，而不是像神秘符号的表格（见图 1.4）。
此外，它们允许根据预定用途来设计语言。
因此，Fortran 是为科学计算设计的，Cobol 是为商业数据处理设计的，Lisp 是为符号操作设计的，等等。
还有针对更小用户群体的领域特定语言，例如对流体模拟感兴趣的用户。
编程语言的第二个优势是提高了程序员的生产力。
软件开发中为数不多的广泛共识之一是，当用需要较少行数来表达一个思想的语言编写程序时，开发程序所需的时间更少。
简洁性是高级语言相对于汇编语言的明显优势。
最后一个优势是，编程语言允许程序独立于其开发所用的计算机，因为编译器和汇编器可以将高级语言程序翻译成任何计算机的二进制指令。
这三个优势如此强大，以至于今天很少有编程工作是用汇编语言完成的。
**1.4**
**揭开面纱**
**输入设备** 计算机通过其获取信息的机制，例如键盘。
**输出设备** 将计算结果传达给用户（如显示器）或另一台计算机的机制。
现在我们已经看过了程序下方的底层软件，让我们打开计算机的外壳，了解一下底层的硬件。
任何计算机的底层硬件都执行相同的基本功能：输入数据、输出数据、处理数据和存储数据。
这些功能是如何执行的，是本书的主要主题，后续章节将处理这四项任务的不同部分。
当我们谈到本书的一个重点，一个我们希望你永远记住的重要观点时，我们会通过将其标识为“大局观”项目来强调它。
本书中我们大约有十几个“大局观”，第一个就是计算机的五个组成部分，它们执行输入、输出、处理和存储数据的任务。
计算机的两个关键组成部分是输入设备（如麦克风）和输出设备（如扬声器）。
顾名思义，输入为计算机提供信息，

\--- PAGE 42 ---

1.4 揭开面纱
17
而输出是计算结果发送给用户。
一些设备，如无线网络，既提供输入也提供输出给计算机。
第 5 章和第 6 章将更详细地描述输入/输出 (I/O) 设备，但让我们先从外部 I/O 设备开始，对计算机硬件进行一次入门之旅。

> **大局观**
>
> 计算机的五个经典组件是输入、输出、存储器、数据通路和控制器，后两者有时被合并称为处理器。图 1.5 展示了一台计算机的标准组织结构。这种组织结构与硬件技术无关：你可以将过去和现在的每一台计算机的每一个部件都归入这五个类别中的一个。为了帮助你全面地看待这一切，计算机的五个组件显示在接下来每一章的首页上，并突出显示了与该章相关部分。
> **计算机的组织结构，展示了五个经典组件。** 处理器从存储器获取指令和数据。输入将数据写入存储器，输出从存储器读取数据。控制器根据数据通路、存储器、输入和输出的操作发送信号。

**图 1.5** 计算机的组织结构，显示了五个经典组件。处理器从内存获取指令和数据。输入将数据写入内存，输出从内存读取数据。控制器发送决定数据通路、内存、输入和输出操作的信号。

\--- PAGE 43 ---

18
第 1 章 计算机抽象与技术
**液晶显示器 (LCD)** 一种显示技术，使用一层薄薄的液晶聚合物，可以根据是否施加电荷来透射或阻挡光线。
**有源矩阵显示** 一种液晶显示器，在每个独立的像素点使用一个晶体管来控制光的透射。
**像素** 最小的独立图像元素。屏幕由数十万到数百万个像素组成，排列成矩阵。
通过计算机显示器，我曾在移动的航母甲板上降落飞机，观察过核粒子撞击势阱，以近光速在火箭中飞行，并看着一台计算机揭示其最深处的运作。—— 伊凡·萨瑟兰，计算机图形学之父，《科学美国人》，1984
**镜中奇遇**
最引人入胜的 I/O 设备可能是图形显示器。
大多数个人移动设备使用液晶显示器 (LCD) 来获得轻薄、低功耗的显示效果。
LCD 本身不是光源；相反，它控制光的透射。
典型的 LCD 包含液体中的杆状分子，这些分子形成一个扭曲的螺旋结构，可以弯曲进入显示器的光线，这些光线要么来自显示器后面的光源，要么较少情况下是反射光。
当施加电流时，杆状分子会变直，不再弯曲光线。
由于液晶材料位于两个偏振角度为 90 度的屏幕之间，除非光线被弯曲，否则无法通过。
如今，大多数 LCD 采用有源矩阵，每个像素都有一个微小的晶体管开关，可以精确控制电流，使图像更清晰。
显示器上每个点都关联一个红-绿-蓝掩模，它决定了最终图像中三种颜色分量的强度；
在彩色有源矩阵 LCD 中，每个点有三个晶体管开关。
图像由一个像素矩阵组成，可以用一个位矩阵来表示，称为位图。
根据屏幕的大小和分辨率，典型平板电脑的显示矩阵尺寸从 $1024 \\times 768$ 到 $2048 \\times 1536$ 不等。彩色显示器可能为三种颜色（红、蓝、绿）中的每一种使用 8 位，即每个像素 24 位，从而可以显示数百万种不同的颜色。
用于图形的计算机硬件支持主要包括一个光栅刷新缓冲器或帧缓冲器，用于存储位图。
要在屏幕上表示的图像存储在帧缓冲器中，每个像素的位模式以刷新率读出到图形显示器。
图 1.6 展示了一个帧缓冲器，其简化设计为每像素仅 4 位。
位图的目标是忠实地表示屏幕上的内容。
图形系统中的挑战之所以出现，是因为人眼非常擅长检测屏幕上即使是微小的变化。

**图 1.6** 左侧帧缓冲器中的每个坐标决定了右侧光栅扫描 CRT 显示器相应坐标的灰度。像素 $(X\_o, Y\_o)$ 包含位模式 0011，它在屏幕上显示的灰度比像素 $(X\_1, Y\_1)$ 中的位模式 1101 更浅。

\--- PAGE 44 ---

1.4 揭开面纱
19
**触摸屏**
虽然个人电脑也使用液晶显示屏，但后 PC 时代的平板电脑和智能手机已经用触摸感应显示屏取代了键盘和鼠标，这具有一个极好的用户界面优势，即用户可以直接指向他们感兴趣的东西，而不是通过鼠标间接指向。
虽然实现触摸屏有多种方式，但今天许多平板电脑使用电容感应技术。
由于人是电导体，如果像玻璃这样的绝缘体上覆盖着透明导体，触摸会扭曲屏幕的静电场，从而导致电容变化。
这项技术可以同时允许多点触控，从而识别可以带来吸引人的用户界面的手势。
**打开盒子**
图 1.7 展示了苹果 iPad 2 平板电脑的内容。
毫不奇怪，在计算机的五个经典组件中，I/O 在这个阅读设备中占主导地位。
I/O 设备列表包括电容式多点触控 LCD、前置摄像头、后置摄像头、麦克风、耳机插孔、扬声器、加速度计、陀螺仪、Wi-Fi 网络和蓝牙网络。
数据通路、控制器和内存只占组件的一小部分。
图 1.8 中的小矩形包含了驱动我们先进技术的设备，称为集成电路，昵称芯片。
在图 1.8 中间看到的 A5 封装包含两个 ARM 处理器，其时钟频率为 1 GHz。
处理器是计算机的活动部分，严格遵循程序的指令。
它进行数字加法、数字测试、向 I/O 设备发信号以激活它们等等。
有时，人们称处理器为 CPU，这是中央处理器单元这个更官僚化的名称的缩写。
**集成电路** 也称为芯片。一种结合了数十到数百万个晶体管的设备。
**中央处理器单元 (CPU)** 也称为处理器。计算机的活动部分，包含数据通路和控制器，并执行加法、测试数字、向 I/O 设备发出激活信号等操作。
**数据通路** 处理器中执行算术运算的组件。
**控制器** 处理器中根据程序指令指挥数据通路、内存和 I/O 设备的组件。
**内存** 程序运行时存放程序的存储区域，也包含运行中程序所需的数据。
**动态随机存取存储器 (DRAM)** 作为集成电路构建的存储器；它提供对任何位置的随机访问。访问时间约为 50 纳秒，2012 年每千兆字节的成本为 5 到 10 美元。
再深入到硬件层面，图 1.9 揭示了微处理器的细节。
处理器在逻辑上由两个主要部分组成：数据通路和控制器，分别是处理器的“肌肉”和“大脑”。
数据通路执行算术运算，控制器根据程序指令的意愿，告诉数据通路、内存和 I/O 设备该做什么。
第 4 章解释了用于更高性能设计的数据通路和控制器。
图 1.8 中的 A5 封装还包括两个存储芯片，每个容量为 2 吉比特，从而提供了 512 MiB。
存储器是程序运行时存放的地方；
它还包含运行中程序所需的数据。存储器由 DRAM 芯片构成。
DRAM 代表动态随机存取存储器。多个 DRAM 共同用于存放程序的指令和数据。
与顺序存取存储器（如磁带）相反，DRAM 中的 RAM 部分意味着无论读取内存的哪个部分，访问时间基本相同。
深入到硬件的任何组件，都能揭示对计算机的见解。
在处理器内部是另一种类型的存储器——高速缓存存储器。

\--- PAGE 45 ---

20
第 1 章 计算机抽象与技术

**图 1.7** 苹果 iPad 2 A1395 的组件。iPad 的金属后盖（中间有倒置的苹果标志）在中央。顶部是电容式多点触控屏幕和 LCD。最右侧是 3.8V、25 瓦时聚合物电池，由三个锂离子电池单元组成，可提供 10 小时的电池续航。最左侧是连接 LCD 到 iPad 背面的金属框架。围绕中央金属后盖的小组件就是我们所认为的“计算机”；它们通常呈 L 形，以便紧凑地安装在电池旁边的机壳内。图 1.8 展示了机壳左下方 L 形板的特写，这是包含处理器和内存的逻辑印刷电路板。逻辑板下方的小矩形包含一个提供无线通信的芯片：Wi-Fi、蓝牙和 FM 调谐器。它安装在逻辑板左下角的一个小插槽中。机壳左上角附近是另一个 L 形组件，是前置摄像头组件，包括摄像头、耳机插孔和麦克风。机壳右上角附近是包含音量控制和静音/屏幕旋转锁定按钮以及陀螺仪和加速度计的电路板。后两个芯片的组合使 iPad 能够识别六轴运动。旁边的小矩形是后置摄像头。机壳右下角附近是 L 形扬声器组件。底部的电缆是逻辑板和摄像头/音量控制板之间的连接线。电缆和扬声器组件之间的电路板是电容触摸屏的控制器。(由 iFixit, [www.ifixit.com](https://www.ifixit.com) 提供)

**图 1.8** 图 1.7 中 Apple iPad 2 的逻辑板。照片突出了五个集成电路。中间的大型集成电路是 Apple A5 芯片，它包含运行在 1 GHz 的双 ARM 处理器核心，以及封装在内的 512 MB 主存。图 1.9 展示了 A5 封装内部处理器芯片的照片。左侧类似大小的芯片是用于非易失性存储的 32 GB 闪存芯片。两个芯片之间有一个空位，可以安装第二块闪存芯片，从而使 iPad 的存储容量翻倍。A5 右侧的芯片包括电源控制器和 I/O 控制器芯片。(由 iFixit, www.ifixit.com 提供)

\--- PAGE 46 ---

**图 1.9** A5 封装内部的处理器集成电路。芯片尺寸为 12.1 毫米 x 10.1 毫米，最初采用 45 纳米工艺制造（见 1.5 节）。它在芯片的中左部有两个相同的 ARM 处理器或核心，在上左象限有一个带有四个数据通路的 PowerVR 图形处理单元（GPU）。ARM 核心的左侧和底部是与主存（DRAM）的接口。(由 Chipworks, [www.chipworks.com](https://www.chipworks.com) 提供)

**高速缓存存储器 (cache memory)** 一种小型、快速的存储器，用作较慢、较大存储器的缓冲区。
**静态随机存取存储器 (SRAM)** 同样是作为集成电路构建的存储器，但比 DRAM 更快、密度更低。
**层次结构**
高速缓存存储器由一种小型、快速的存储器组成，作为 DRAM 存储器的缓冲区。
（cache 的非技术性定义是隐藏东西的安全地方。）
缓存使用不同的存储技术构建，即静态随机存取存储器 (SRAM)。
SRAM 比 DRAM 更快但密度更低，因此更昂贵（见第 5 章）。
SRAM 和 DRAM 是存储器层次结构的两个层次。

\--- PAGE 47 ---

22
第 1 章 计算机抽象与技术
**抽象**
**指令集架构** 也称为架构。硬件和最低层软件之间的一个抽象接口，它包含了编写一个能正确运行的机器语言程序所必需的所有信息，包括指令、寄存器、内存访问、I/O 等。
**应用程序二进制接口 (ABI)** 指令集的用户部分加上应用程序员使用的操作系统接口。它为跨计算机的二进制可移植性定义了一个标准。
**实现** 遵循架构抽象的硬件。
**易失性存储器** 如 DRAM 这样的存储器，只有在通电时才能保存数据。
**非易失性存储器** 一种即使在没有电源的情况下也能保留数据的存储器形式，用于在两次运行之间存储程序。DVD 光盘是非易失性的。

> **大局观**
>
> 硬件和软件都由使用抽象的分层结构组成，每一层都对上层隐藏细节。抽象层次之间的一个关键接口是指令集架构——硬件和低级软件之间的接口。这个抽象接口使得许多不同成本和性能的实现能够运行相同的软件。
> 如上所述，改进设计的一大思想是抽象。
> 最重要的抽象之一是硬件与最低层软件之间的接口。
> 由于其重要性，它被赋予了一个特殊的名称：指令集架构，或简称为计算机的架构。
> 指令集架构包括程序员需要知道的、使二进制机器语言程序正确工作的一切，包括指令、I/O 设备等等。
> 通常，操作系统会封装 I/O 操作、内存分配和其他低级系统功能的细节，这样应用程序员就不需要担心这些细节。
> 基本指令集和为应用程序员提供的操作系统接口的组合称为应用程序二进制接口 (ABI)。
> 指令集架构允许计算机设计者在不依赖于执行功能的硬件的情况下讨论功能。
> 例如，我们可以讨论数字时钟的功能（计时、显示时间、设置闹钟），而与时钟的硬件（石英晶体、LED 显示屏、塑料按钮）分开。
> 计算机设计者以同样的方式区分架构和架构的实现：实现是遵循架构抽象的硬件。
> 这些想法带我们来到了另一个“大局观”。
> **数据的安全之所**
> 到目前为止，我们已经看到了如何输入数据、使用数据进行计算以及显示数据。
> 然而，如果计算机断电，所有东西都会丢失，因为计算机内部的内存是易失性的——也就是说，断电后它会忘记。
> 相比之下，DVD 光盘在您关闭 DVD 播放机电源时不会忘记电影，因此它是一种非易失性存储技术。

\--- PAGE 48 ---

1.4 揭开面纱
23
**层次结构**
**主存** 也称为一级存储器。用于在程序运行时存放程序的存储器；在当今的计算机中通常由 DRAM 组成。
**二级存储器** 用于在两次运行之间存储程序和数据的非易失性存储器；在 PMD 中通常由闪存组成，在服务器中由磁盘组成。
**磁盘** 也称为硬盘。一种由涂有磁记录材料的旋转盘片组成的非易失性二级存储器。由于它们是旋转的机械设备，访问时间约为 5 到 20 毫秒，2012 年每千兆字节的成本为 0.05 到 0.10 美元。
**闪存** 一种非易失性半导体存储器。它比 DRAM 便宜且慢，但每比特比磁盘贵且快。访问时间约为 5 到 50 微秒，2012 年每千兆字节的成本为 0.75 到 1.00 美元。
为了区分用于在运行时存放数据和程序的易失性存储器和用于在两次运行之间存储数据和程序的非易失性存储器，前者使用术语主存或一级存储器，后者使用二级存储器。
二级存储器构成了存储器层次结构的下一层。
自 1975 年以来，DRAM 一直主导着主存，但磁盘在更早的时候就开始主导二级存储器。
由于其尺寸和外形，个人移动设备使用闪存，一种非易失性半导体存储器，而不是磁盘。
图 1.8 显示了包含 iPad 2 闪存的芯片。虽然比 DRAM 慢，但它比 DRAM 便宜得多，而且是非易失性的。
尽管每比特成本高于磁盘，但它体积更小，容量也小得多，比磁盘更坚固，功耗也更低。
因此，闪存是 PMD 的标准二级存储器。
唉，与磁盘和 DRAM 不同，闪存的比特在 10 万到 100 万次写入后会磨损。
因此，文件系统必须跟踪写入次数，并采取策略避免存储磨损，例如通过移动常用数据。
第 5 章更详细地描述了磁盘和闪存。
**与其他计算机通信**
我们已经解释了如何输入、计算、显示和保存数据，但今天的计算机中还有一个缺失的项：计算机网络。
就像图 1.5 中所示的处理器连接到内存和 I/O 设备一样，网络将整个计算机互连起来，允许计算机用户通过包括通信来扩展计算的能力。
网络变得如此流行，以至于它们是当前计算机系统的支柱；
一个没有网络接口的新个人移动设备或服务器会受到嘲笑。联网计算机有几个主要优势：
■ **通信：** 信息在计算机之间高速交换。
■ **资源共享：** 网络上的计算机可以共享 I/O 设备，而不是每台计算机都有自己的 I/O 设备。
■ **非本地访问：** 通过长距离连接计算机，用户不必在他们正在使用的计算机附近。
网络的长度和性能各不相同，通信成本随着通信速度和信息传输距离的增加而增加。
也许最流行的网络类型是以太网。它可以长达一公里，传输速率高达每秒 40 吉比特。
它的长度和速度使以太网可用于连接同一建筑物同一楼层的计算机；

\--- PAGE 49 ---

24
第 1 章 计算机抽象与技术
**局域网 (LAN)** 一种设计用于在地理上受限的区域内（通常在单个建筑物内）传输数据的网络。
**广域网 (WAN)** 一种跨越数百公里，可以覆盖一个大陆的网络。

> **自测**
> 因此，它是通常所说的局域网的一个例子。
> 局域网通过交换机互连，交换机也可以提供路由服务和安全性。
> 广域网跨越大陆，是支持网络的互联网的骨干。
> 它们通常基于光纤，并从电信公司租用。
> 在过去的 30 年里，网络改变了计算的面貌，既变得更加普遍，又在性能上取得了显著的提升。
> 在 20 世纪 70 年代，很少有人能接触到电子邮件，互联网和网络还不存在，物理邮寄磁带是两个地点之间传输大量数据的主要方式。
> 局域网几乎不存在，少数现有的广域网容量有限且访问受限。
> 随着网络技术的改进，它变得相当便宜并且容量显著提高。
> 例如，大约 30 年前开发的第一个标准化局域网技术，是以太网的一个版本，其最大容量（也称为带宽）为每秒 1000 万比特，通常由几十台甚至上百台计算机共享。
> 如今，局域网技术提供的容量从每秒 1 到 40 吉比特不等，通常最多由几台计算机共享。
> 光通信技术也使得广域网的容量实现了类似的增长，从数百千比特到吉比特，从数百台计算机连接到全球网络到数百万台计算机连接。
> 这种网络部署的急剧增长与容量的增加相结合，使得网络技术成为过去 30 年信息革命的核心。
> 在过去十年里，网络领域的另一项创新正在重塑计算机通信的方式。
> 无线技术已经普及，这催生了后 PC 时代。能够用与存储器和微处理器相同的低成本半导体技术 (CMOS) 制造无线电，使得价格大幅改善，导致部署爆炸式增长。
> 目前可用的无线技术，其 IEEE 标准名称为 802.11，允许的传输速率从每秒 1 百万比特到近 1 亿比特。
> 无线技术与有线网络有很大不同，因为一个区域内的所有用户共享电波。
> 半导体 DRAM 存储器、闪存和磁盘存储有显著不同。
> 对于每种技术，列出其易失性、近似的相对访问时间以及与 DRAM 相比的近似相对成本。
> **1.5**
> **构建处理器和存储器的技术**
> 处理器和存储器以惊人的速度改进，因为计算机设计者长期以来一直拥抱最新的电子技术，试图在设计更好的计算机的竞赛中获胜。
> 图 1.10 展示了随时间使用的技术。

\--- PAGE 50 ---

| 年份 | 计算机中使用的技术 | 相对性能/单位成本 |
| :--- | :--- | :--- |
| 1951 | 真空管 | 1 |
| 1965 | 晶体管 | 35 |
| 1975 | 集成电路 | 900 |
| 1995 | 超大规模集成电路 | 2,400,000 |
| 2013 | 极大规模集成电路 | 250,000,000,000 |

**图 1.10 随时间推移，计算机中使用技术的相对单位成本性能。** 来源：波士顿计算机博物馆，2013年数据由作者推断。见 1.12 节。
**晶体管** 一种由电信号控制的开关。
**超大规模集成 (VLSI) 电路** 一种包含数十万到数百万晶体管的设备。
**硅** 一种是半导体的天然元素。
**半导体** 一种导电性不佳的物质。
每单位成本的相对性能。
由于这项技术决定了计算机能做什么以及它们将以多快的速度发展，我们相信所有计算机专业人士都应该熟悉集成电路的基础知识。
晶体管只是一个由电控制的开关。
集成电路 (IC) 将数十到数百个晶体管组合成一个单一的芯片。
当戈登·摩尔预测资源将持续翻倍时，他预测的是每个芯片上晶体管数量的增长率。
为了描述晶体管数量从几百个到几百万个的巨大增长，人们在术语前加上了“超大规模”这个形容词，创造了 VLSI 这个缩写，即超大规模集成电路。
这种集成度增长的速度非常稳定。图 1.11 显示了自 1977 年以来 DRAM 容量的增长。35 年来，该行业每 3 年容量翻四番，增长超过 16,000 倍！
要理解如何制造集成电路，我们从头开始。
芯片的制造始于硅，一种在沙子中发现的物质。
因为硅导电性不好，所以被称为半导体。
通过特殊的化学过程，可以向硅中添加材料，使微小区域转变为三种设备之一：
■ 优良的电导体（使用微观的铜线或铝线）

**图 1.11** DRAM 芯片容量随时间的增长。y轴以 Kibibits（$2^{10}$ 位）为单位。DRAM 行业在 20 年里几乎每三年容量就翻两番，年增长率达到 60%。近年来，增长率有所放缓，更接近每两到三年翻一番。

\--- PAGE 51 ---

26
第 1 章 计算机抽象与技术
**硅晶锭** 一种由硅晶体组成的棒，直径在 8 到 12 英寸之间，长约 12 到 24 英寸。
**晶圆** 从硅晶锭上切下的薄片，厚度不超过 0.1 英寸，用于制造芯片。
■ 优良的电绝缘体（如塑料护套或玻璃）
■ 在特定条件下可以导电或绝缘的区域（作为开关）
晶体管属于最后一类。因此，一个 VLSI 电路只是数十亿个导体、绝缘体和开关的组合，制造在一个小小的封装中。
集成电路的制造过程对芯片的成本至关重要，因此对计算机设计者来说很重要。
图 1.12 显示了这个过程。该过程始于一个硅晶锭，它看起来像一根巨大的香肠。
如今，晶锭的直径为 8-12 英寸，长约 12-24 英寸。
一个晶锭被精细地切成厚度不超过 0.1 英寸的晶圆。
然后，这些晶圆经过一系列处理步骤，在此期间，化学物质的图案被放置在每个晶圆上，从而制造出前面讨论的晶体管、导体和绝缘体。
如今的集成电路只包含一层晶体管，但可能有多达两到八层的金属导体，由绝缘层隔开。

**图 1.12** 芯片制造过程。从硅锭切下后，空白晶圆经过 20 到 40 个步骤，形成图案化晶圆（见图 1.13）。然后用晶圆测试仪对这些图案化晶圆进行测试，并绘制出合格部分的地图。接下来，晶圆被切割成晶粒（见图 1.9）。在此图中，一个晶圆生产了 20 个晶粒，其中 17 个通过了测试。（X 表示晶粒不合格。）在这种情况下，良品率为 17/20，即 85%。然后将这些合格的晶粒封装起来，在运送给客户之前再进行一次测试。在这次最终测试中发现了一个不合格的封装部件。
**缺陷** 晶圆或图案化步骤中的微观瑕疵，可能导致包含该缺陷的晶粒失效。
晶圆本身或数十个图案化步骤中的一个微小瑕疵，都可能导致晶圆的那个区域失效。
这些被称为缺陷的东西，使得制造一个完美的晶圆几乎是不可能的。
应对不完美的最简单方法是在单个晶圆上放置许多独立的组件。
然后将图案化的晶圆切成这些组件，

\--- PAGE 52 ---

1.5 构建处理器和存储器的技术
27

**图 1.13** 一片 12 英寸 (300mm) 的 Intel Core i7 晶圆 (由 Intel 提供)。在 100% 良率下，这片 300mm (12 英寸) 晶圆上的晶粒数量为 280 个，每个晶粒尺寸为 20.7 x 10.5 mm。晶圆边缘的几十个部分圆形的芯片是无用的；包含它们是因为创建用于图案化硅的掩模更容易。该晶粒采用 32 纳米技术，这意味着最小特征尺寸约为 32 纳米，尽管它们通常比实际特征尺寸稍小，后者指的是晶体管的“绘制”尺寸与最终制造尺寸的对比。

**晶粒** 从晶圆上切割下来的独立矩形部分，更通俗地称为芯片。
**良率** 合格晶粒占晶圆上总晶粒数的百分比。
称为晶粒，非正式地也称为芯片。图 1.13 展示了一张包含微处理器的晶圆的照片，这些微处理器尚未被切割；
早些时候，图 1.9 展示了一个单独的微处理器晶粒。
切割使你能够只丢弃那些不幸包含缺陷的晶粒，而不是整个晶圆。
这个概念通过一个过程的良率来量化，良率定义为晶圆上合格晶粒占总晶粒数的百分比。
随着晶粒尺寸的增加，集成电路的成本迅速上升，这既是由于良率降低，也是由于一个晶圆上能容纳的晶粒数量减少。
为了降低成本，下一代工艺通过使用更小的晶体管和导线尺寸来缩小大晶粒。
这提高了每个晶圆的良率和晶粒数量。
2012 年，32 纳米 (nm) 工艺是典型的，这基本上意味着晶粒上最小的特征尺寸是 32 纳米。

-----

以上是第 32-51 页的翻译。请您先复制或导出。

好的，我们继续。

这是第二部分，包含 **第 52 页到第 71 页** 的翻译内容。

-----

\--- PAGE 52 ---

1.5 构建处理器和存储器的技术
27

**图 1.13** 一片 12 英寸 (300mm) 的 Intel Core i7 晶圆 (由 Intel 提供)。在 100% 良率下，这片 300mm (12 英寸) 晶圆上的晶粒数量为 280 个，每个晶粒尺寸为 20.7 x 10.5 mm。晶圆边缘的几十个部分圆形的芯片是无用的；包含它们是因为创建用于图案化硅的掩模更容易。该晶粒采用 32 纳米技术，这意味着最小特征尺寸约为 32 纳米，尽管它们通常比实际特征尺寸稍小，后者指的是晶体管的“绘制”尺寸与最终制造尺寸的对比。

称为晶粒，非正式地也称为芯片。图 1.13 展示了一张包含微处理器的晶圆的照片，这些微处理器尚未被切割；
早些时候，图 1.9 展示了一个单独的微处理器晶粒。
**晶粒 (die)** 从晶圆上切下的独立矩形部分，更通俗地称为芯片。
**良率 (yield)** 合格晶粒占晶圆上总晶粒数的百分比。
切割使你能够只丢弃那些不幸包含缺陷的晶粒，而不是整个晶圆。
这个概念通过一个过程的良率来量化，良率定义为晶圆上合格晶粒占总晶粒数的百分比。
随着晶粒尺寸的增加，集成电路的成本迅速上升，这既是由于良率降低，也是由于一个晶圆上能容纳的晶粒数量减少。
为了降低成本，下一代工艺通过使用更小的晶体管和导线尺寸来缩小大晶粒。
这提高了每个晶圆的良率和晶粒数量。
2012 年，32 纳米 (nm) 工艺是典型的，这基本上意味着晶粒上最小的特征尺寸是 32 纳米。

\--- PAGE 53 ---

28
第 1 章 计算机抽象与技术
**阐述：** 集成电路的成本可以用三个简单的方程来表示：
$$\text{每个晶粒的成本} = \frac{\text{每个晶圆的成本}}{\text{每个晶圆的晶粒数} \times \text{良率}}$$
$$\text{每个晶圆的晶粒数} \approx \frac{\text{晶圆面积}}{\text{晶粒面积}}$$
$$\text{良率} = \frac{1}{(1 + (\text{单位面积缺陷数} \times \text{晶粒面积} / 2))^2}$$
第一个方程很容易推导。第二个是近似值，因为它没有减去圆形晶圆边缘附近无法容纳矩形晶粒的面积（见图 1.13）。
最后一个方程是基于集成电路工厂良率的经验观察，指数与关键处理步骤的数量有关。
因此，根据缺陷率以及晶粒和晶圆的尺寸，成本通常与晶粒面积不成线性关系。

> **自测**
>
> 决定集成电路成本的一个关键因素是产量。
> 以下哪项是大批量生产的芯片成本应该更低的原因？
>
> 1.  大批量生产时，制造过程可以针对特定设计进行调整，从而提高良率。
> 2.  设计大批量零件比设计小批量零件的工作量小。
> 3.  用于制造芯片的掩模很昂贵，因此对于更高的产量，每个芯片的成本更低。
> 4.  工程开发成本高，且基本上与产量无关；因此，对于大批量零件，每个晶粒的开发成本更低。
> 5.  大批量零件通常比小批量零件的晶粒尺寸小，因此每个晶圆的良率更高。
>     **1.6**
>     **性能**
>     评估计算机的性能可能相当具有挑战性。现代软件系统的规模和复杂性，加上硬件设计者采用的各种性能改进技术，使得性能评估变得更加困难。
>     在试图选择不同的计算机时，性能是一个重要的属性。
>     准确测量和比较不同的计算机对购买者至关重要，因此对设计者也很重要。

\--- PAGE 54 ---

1.6 性能
销售计算机的人也知道这一点。
销售人员通常希望你以最好的角度看待他们的计算机，无论这种角度是否准确反映了购买者应用的需求。
因此，了解如何最好地衡量性能以及这些测量的局限性，在选择计算机时非常重要。
本节的其余部分描述了可以确定性能的不同方法；
然后，我们从计算机用户和设计者的角度描述了衡量性能的指标。
我们还将研究这些指标是如何相关的，并介绍经典的处理器性能方程，我们将在整个文本中使用它。
**定义性能**
当我们说一台计算机的性能比另一台好时，我们是什么意思？
尽管这个问题看起来可能很简单，但一个与客机的类比显示了性能问题可以有多么微妙。
图 1.14 列出了一些典型的客机，以及它们的巡航速度、航程和载客量。
如果我们想知道这张表中的哪架飞机性能最好，我们首先需要定义性能。
例如，考虑到不同的性能衡量标准，我们看到巡航速度最高的飞机是协和式飞机（2003 年退役），航程最长的飞机是 DC-8，而载客量最大的飞机是 747。

| 飞机 | 载客量 | 巡航航程 (英里) | 巡航速度 (英里/小时) | 乘客吞吐量 (乘客 x 英里/小时) |
| :--- | :--- | :--- | :--- | :--- |
| 波音 777 | 375 | 4630 | 610 | 228,750 |
| 波音 747 | 470 | 4150 | 610 | 286,700 |
| BAC/Sud 协和式 | 132 | 4000 | 1350 | 178,200 |
| 道格拉斯 DC-8-50 | 146 | 8720 | 544 | 79,424 |

29
**图 1.14 若干商用飞机的载客量、航程和速度。** 最后一列显示了飞机运输乘客的速率，即载客量乘以巡航速度（忽略航程以及起飞和降落时间）。
让我们假设我们根据速度来定义性能。这仍然留下了两种可能的定义。
你可以把最快的飞机定义为巡航速度最高的那架，它能在最短的时间内将一名乘客从一个点带到另一个点。
然而，如果你想把 450 名乘客从一个点运到另一个点，那么 747 显然是最快的，正如上图最后一列所示。
同样，我们可以用几种不同的方式来定义计算机性能。
如果你在两台不同的台式电脑上运行一个程序，你会说更快的那台是先完成工作的台式电脑。
如果你管理一个数据中心，里面有几台服务器运行着许多用户提交的作业，你会说更快的计算机是在一天内完成最多作业的那台。
作为个人计算机用户，你关心的是减少响应时间——任务开始和完成之间的时间，也称为
**响应时间** 也称为执行时间。计算机完成一个任务所需的总时间，包括磁盘访问、内存访问、I/O 活动、操作系统开销、CPU 执行时间等等。

\--- PAGE 55 ---

30
第 1 章 计算机抽象与技术
**吞吐量** 也称为带宽。性能的另一种衡量标准，是单位时间内完成的任务数量。
执行时间。数据中心管理者通常关心提高吞吐量或带宽——在给定时间内完成的总工作量。
因此，在大多数情况下，我们需要不同的性能指标以及不同的应用程序集来对个人移动设备进行基准测试（更侧重于响应时间），而不是服务器（更侧重于吞吐量）。
**示例**
**吞吐量与响应时间**
对计算机系统的以下更改是增加吞吐量、减少响应时间，还是两者兼而有之？

1.  用更快的处理器替换计算机中的处理器
2.  向一个使用多个处理器处理独立任务的系统（例如，搜索网页）中增加额外的处理器
    **答案**
    减少响应时间几乎总能提高吞吐量。因此，在情况 1 中，响应时间和吞吐量都得到了改善。
    在情况 2 中，没有任何一个任务能更快地完成工作，所以只有吞吐量增加。
    然而，如果在第二种情况下，处理需求几乎与吞吐量一样大，系统可能会迫使请求排队。
    在这种情况下，增加吞吐量也可以改善响应时间，因为它会减少在队列中的等待时间。
    因此，在许多真实的计算机系统中，改变执行时间或吞吐量通常会影响另一个。
    在讨论计算机性能时，我们主要关心前几章的响应时间。
    为了最大化性能，我们希望最小化某个任务的响应时间或执行时间。
    因此，我们可以将计算机 X 的性能和执行时间联系起来：
    $$\text{性能}_X = \frac{1}{\text{执行时间}_X}$$
    这意味着对于两台计算机 X 和 Y，如果 X 的性能大于 Y 的性能，我们有
    $$\text{性能}_X > \text{性能}_Y$$
    $$\frac{1}{\text{执行时间}_X} > \frac{1}{\text{执行时间}_Y}$$
    $$\text{执行时间}_Y > \text{执行时间}_X$$
    也就是说，如果 X 比 Y 快，那么 Y 的执行时间比 X 长。

\--- PAGE 56 ---

1.6 性能
在讨论计算机设计时，我们经常希望量化比较两台不同计算机的性能。
我们将使用短语“X 比 Y 快 n 倍”——或等效地“X 的速度是 Y 的 n 倍”——来表示
$$\frac{\text{性能}_X}{\text{性能}_Y} = n$$
如果 X 的速度是 Y 的 n 倍，那么 Y 的执行时间是 X 的 n 倍：
$$\frac{\text{性能}_X}{\text{性能}_Y} = \frac{\text{执行时间}_Y}{\text{执行时间}_X} = n$$
**示例**
**相对性能**
如果计算机 A 运行一个程序需要 10 秒，计算机 B 运行同一个程序需要 15 秒，那么 A 比 B 快多少？
**答案**
我们知道，如果
$$\frac{\text{性能}_A}{\text{性能}_B} = \frac{\text{执行时间}_B}{\text{执行时间}_A} = n$$
那么 A 的速度是 B 的 n 倍。因此性能比为
$$\frac{15}{10} = 1.5$$
因此 A 的速度是 B 的 1.5 倍。
在上面的例子中，我们也可以说计算机 B 比计算机 A 慢 1.5 倍，因为
$$\frac{\text{性能}_A}{\text{性能}_B} = 1.5$$
意味着
$$\text{性能}_A = 1.5 \times \text{性能}_B$$
31

\--- PAGE 57 ---

32
第 1 章 计算机抽象与技术
**CPU 执行时间** 也称为 CPU 时间。CPU 为特定任务进行计算的实际时间。
**用户 CPU 时间** 在程序本身中花费的 CPU 时间。
**系统 CPU 时间** 在操作系统中为程序执行任务所花费的 CPU 时间。
为简单起见，当我们试图量化比较计算机时，我们通常使用“快多少”这样的术语。
因为性能和执行时间是倒数关系，提高性能需要减少执行时间。
为了避免“增加”和“减少”这两个词可能引起的混淆，我们通常说“提高性能”或“改善执行时间”，意思分别是“增加性能”和“减少执行时间”。
**衡量性能**
时间是衡量计算机性能的标准：在最少时间内完成相同工作量的计算机就是最快的。
程序执行时间以“秒/程序”为单位。然而，时间可以根据我们计算的内容以不同的方式定义。
最直接的时间定义称为墙上时钟时间、响应时间或经过时间。
这些术语意味着完成任务的总时间，包括磁盘访问、内存访问、输入/输出 (I/O) 活动、操作系统开销——所有的一切。
然而，计算机通常是共享的，一个处理器可能同时处理多个程序。
在这种情况下，系统可能会尝试优化吞吐量，而不是试图最小化一个程序的经过时间。
因此，我们常常希望区分经过时间和处理器为我们工作的时间。
**CPU 执行时间** 或简称 **CPU 时间**，认识到这种区别，是 CPU 为此任务花费的计算时间，不包括等待 I/O 或运行其他程序的时间。
（但请记住，用户体验到的响应时间将是程序的经过时间，而不是 CPU 时间。）CPU 时间可以进一步分为程序中花费的 CPU 时间，称为**用户 CPU 时间**，以及在操作系统中为程序执行任务所花费的 CPU 时间，称为**系统 CPU 时间**。
准确区分系统和用户 CPU 时间是很困难的，因为通常很难将操作系统活动的责任分配给某个特定的用户程序，而不是另一个，也因为操作系统之间的功能差异。
为了一致性，我们对基于经过时间的性能和基于 CPU 执行时间的性能进行了区分。
我们将使用术语**系统性能**来指代在未加载系统上的经过时间，而**CPU 性能**则指用户 CPU 时间。
在本章中，我们将重点关注 CPU 性能，尽管我们关于如何总结性能的讨论可以应用于经过时间或 CPU 时间的测量。

> **理解程序性能**
>
> 不同的应用程序对计算机系统性能的不同方面敏感。许多应用程序，特别是运行在服务器上的应用程序，同样依赖于 I/O 性能，而 I/O 性能又依赖于硬件和软件。
>
> **性能**
>
> 总的经过时间（由挂钟测量）是关注的测量指标。在某些应用环境中，用户可能关心吞吐量、响应时间，或两者的复杂组合（例如，在最坏响应时间下的最大吞吐量）。要提高程序的性能，必须清楚地定义哪个性能指标是重要的，然后通过测量程序执行并寻找可能的瓶颈来找到性能瓶颈。在接下来的章节中，我们将描述如何搜索瓶颈并提高系统中各个部分的性能。

\--- PAGE 58 ---

1.6 性能
33
虽然作为计算机用户我们关心时间，但当我们检查计算机的细节时，用其他指标来考虑性能会更方便。
特别是，计算机设计者可能希望使用一种与硬件执行基本功能的速度相关的度量来考虑计算机。
几乎所有的计算机都使用一个时钟来确定硬件中事件发生的时间。
这些离散的时间间隔被称为**时钟周期**（或滴答、时钟滴答、时钟周期、时钟、周期）。
设计者将一个时钟周期的长度称为完整的时钟周期时间（例如，250 皮秒，或 250 ps），也称为**时钟频率**（例如，4 吉赫兹，或 4 GHz），它是时钟周期的倒数。
在下一小节中，我们将正式化硬件设计者的时钟周期与计算机用户的秒之间的关系。
**时钟周期** 也称为滴答、时钟滴答、时钟周期、时钟或周期。一个时钟周期的时间，通常是处理器时钟的周期，它以恒定的速率运行。
**时钟周期** 每个时钟周期的长度。

> **自测**
>
> 1.  假设我们知道一个同时使用个人移动设备和云的应用受限于网络性能。对于以下变化，说明是只有吞吐量提高，响应时间和吞吐量都提高，还是两者都未提高。
>     a. 在 PMD 和云之间增加一个额外的网络通道，增加了总网络吞吐量并减少了获得网络访问的延迟（因为现在有两个通道）。
>     b. 改进了网络软件，从而减少了网络通信延迟，但没有增加吞吐量。
>     c. 计算机增加了更多内存。
> 2.  计算机 C 的性能是计算机 B 的四倍，计算机 B 运行一个给定的应用程序需要 28 秒。计算机 C 运行该应用程序需要多长时间？
>     **CPU 性能及其影响因素**
>     用户和设计者通常使用不同的指标来考察性能。如果我们能够关联这些不同的指标，我们就能确定一个设计变更对用户体验到的性能的影响。
>     由于我们目前只关注 CPU 性能，底线的性能衡量标准是 CPU

\--- PAGE 59 ---

34
第 1 章 计算机抽象与技术
执行时间。一个简单的公式将最基本的指标（时钟周期和时钟周期时间）与 CPU 时间关联起来：
$$\text{一个程序的 CPU 执行时间} = \text{一个程序的 CPU 时钟周期数} \times \text{时钟周期时间}$$
或者，因为时钟频率和时钟周期时间是倒数关系，
$$\text{一个程序的 CPU 执行时间} = \frac{\text{一个程序的 CPU 时钟周期数}}{\text{时钟频率}}$$
这个公式清楚地表明，硬件设计者可以通过减少一个程序所需的时钟周期数或缩短时钟周期的长度来提高性能。
正如我们将在后面的章节中看到的，设计者常常面临一个程序所需的时钟周期数与每个周期长度之间的权衡。
许多减少时钟周期数的技术也可能增加时钟周期时间。
**示例**
**提高性能**
我们最喜欢的程序在计算机 A 上运行需要 10 秒，该计算机有一个 2 GHz 的时钟。
我们正在帮助一个计算机设计者构建一台计算机 B，它将能用 6 秒运行这个程序。
设计者已经确定，时钟频率可以大幅提高，但这种提高会影响 CPU 的其余设计，导致计算机 B 对这个程序需要比计算机 A 多 1.2 倍的时钟周期。
我们应该告诉设计者目标时钟频率是多少？
**答案**
让我们首先找出程序在 A 上所需的时钟周期数：
$$\text{CPU 时间}_A = \frac{\text{CPU 时钟周期}_A}{\text{时钟频率}_A}$$
$$10 \text{ 秒} = \frac{\text{CPU 时钟周期}_A}{2 \times 10^9 \text{ 周期/秒}}$$
$$\text{CPU 时钟周期}_A = 10 \text{ 秒} \times 2 \times 10^9 \frac{\text{周期}}{\text{秒}} = 20 \times 10^9 \text{ 周期}$$

\--- PAGE 60 ---

1.6 性能
35
B 的 CPU 时间可以通过这个方程找到：
$$\text{CPU 时间}_B = \frac{1.2 \times \text{CPU 时钟周期}_A}{\text{时钟频率}_B}$$
$$6 \text{ 秒} = \frac{1.2 \times 20 \times 10^9 \text{ 周期}}{\text{时钟频率}_B}$$
$$\text{时钟频率}_B = \frac{1.2 \times 20 \times 10^9 \text{ 周期}}{6 \text{ 秒}} = \frac{0.2 \times 20 \times 10^9 \text{ 周期}}{\text{秒}} = \frac{4 \times 10^9 \text{ 周期}}{\text{秒}} = 4 \text{ GHz}$$
为了在 6 秒内运行该程序，B 必须拥有 A 两倍的时钟频率。
**指令性能**
上述性能方程没有提及程序所需的指令数。
然而，既然编译器明确生成了要执行的指令，并且计算机必须执行这些指令来运行程序，那么执行时间必定取决于程序中的指令数。
一种思考执行时间的方式是，它等于执行的指令数乘以每条指令的平均时间。
因此，一个程序所需的时钟周期数可以写成
$$\text{CPU 时钟周期} = \text{程序的指令数} \times \text{每条指令的平均时钟周期数}$$
**每条指令的时钟周期数 (CPI)** 程序或程序片段中每条指令的平均时钟周期数。
术语“每条指令的时钟周期数”，即每条指令执行所需的平均时钟周期数，通常缩写为 CPI。
由于不同的指令根据其功能可能需要不同的时间，CPI 是程序中所有执行指令的平均值。
CPI 提供了一种比较同一指令集架构的两种不同实现的方法，因为一个程序执行的指令数当然是相同的。
**示例**
**使用性能方程**
假设我们有两个相同指令集架构的实现。
计算机 A 对于某个程序的时钟周期时间为 250 ps，CPI 为 2.0；而计算机 B 对于同一个程序的时钟周期时间为 500 ps，CPI 为 1.2。
对于这个程序，哪台计算机更快？快多少？

\--- PAGE 61 ---

36
**答案**
第 1 章 计算机抽象与技术
我们知道每台计算机为该程序执行的指令数是相同的；
我们称这个数为 I。首先，找出每台计算机的处理器时钟周期数：
$$\text{CPU 时钟周期}_A = I \times 2.0$$
$$\text{CPU 时钟周期}_B = I \times 1.2$$
现在我们可以计算每台计算机的 CPU 时间：
**指令数** 程序执行的指令数量。
$$\text{CPU 时间}_A = \text{CPU 时钟周期}_A \times \text{时钟周期时间}_A = I \times 2.0 \times 250 \text{ ps} = 500 \times I \text{ ps}$$
同样，对于 B：
$$\text{CPU 时间}_B = I \times 1.2 \times 500 \text{ ps} = 600 \times I \text{ ps}$$
显然，计算机 A 更快。快多少由执行时间的比率给出：
$$\frac{\text{CPU 性能}_A}{\text{CPU 性能}_B} = \frac{\text{执行时间}_B}{\text{执行时间}_A} = \frac{600 \times I \text{ ps}}{500 \times I \text{ ps}} = 1.2$$
我们可以得出结论，对于这个程序，计算机 A 比计算机 B 快 1.2 倍。
**经典 CPU 性能方程**
我们现在可以根据指令数（程序执行的指令数）、CPI 和时钟周期时间来写出这个基本性能方程：
$$\text{CPU 时间} = \text{指令数} \times \text{CPI} \times \text{时钟周期时间}$$
或者，由于时钟频率是时钟周期时间的倒数：
$$\text{CPU 时间} = \frac{\text{指令数} \times \text{CPI}}{\text{时钟频率}}$$
这些公式特别有用，因为它们分开了影响性能的三个关键因素。
我们可以使用这些公式来比较两种不同的实现，或者如果我们知道设计方案对这三个参数的影响，就可以评估一个设计方案。

\--- PAGE 62 ---

1.6 性能
37
**示例**
**比较代码段**
一位编译器设计者正试图为一台计算机在两个代码序列之间做出选择。
硬件设计者提供了以下事实：
**每种指令类别的 CPI**
| | CPI |
| :--- | :--- |
| A | 1 |
| B | 2 |
| C | 3 |
对于一个特定的高级语言语句，编译器编写者正在考虑两个需要以下指令数的代码序列：

| | **各种指令的指令数** | |
| :--- | :--- | :--- |
| **代码序列** | **A** | **B** | **C** |
| 1 | 2 | 1 | 2 |
| 2 | 4 | 1 | 1 |

哪个代码序列执行的指令最多？哪个会更快？每个序列的 CPI 是多少？
**答案**
序列 1 执行 $2+1+2=5$ 条指令。序列 2 执行 $4+1+1=6$ 条指令。因此，序列 1 执行的指令更少。
我们可以使用基于指令数和 CPI 的 CPU 时钟周期方程来找出每个序列的总时钟周期数：
$$\text{CPU 时钟周期} = \sum_{i=1}^{n} (\text{CPI}_i \times C_i)$$
这得出
$$\text{CPU 时钟周期}_1 = (2 \times 1) + (1 \times 2) + (2 \times 3) = 2 + 2 + 6 = 10 \text{ 周期}$$
$$\text{CPU 时钟周期}_2 = (4 \times 1) + (1 \times 2) + (1 \times 3) = 4 + 2 + 3 = 9 \text{ 周期}$$
所以代码序列 2 更快，尽管它多执行了一条指令。
由于代码序列 2 总共需要的时钟周期更少，但指令数更多，所以它的 CPI 必须更低。
CPI 值可以这样计算：
$$\text{CPI} = \frac{\text{CPU 时钟周期}}{\text{指令数}}$$
$$\text{CPI}_1 = \frac{\text{CPU 时钟周期}_1}{\text{指令数}_1} = \frac{10}{5} = 2.0$$
$$\text{CPI}_2 = \frac{\text{CPU 时钟周期}_2}{\text{指令数}_2} = \frac{9}{6} = 1.5$$

\--- PAGE 63 ---

38
第 1 章 计算机抽象与技术

> **大局观**
>
> 图 1.15 显示了计算机不同层面的基本测量以及在每种情况下正在测量什么。我们可以看到这些因素如何组合起来，得出以“秒/程序”为单位的执行时间：
>
> $$\text{时间} \left( \frac{\text{秒}}{\text{程序}} \right) = \frac{\text{指令数}}{\text{程序}} \times \frac{\text{时钟周期数}}{\text{指令}} \times \frac{\text{秒}}{\text{时钟周期}}$$
>
> 始终牢记，唯一完整可靠的计算机性能衡量标准是时间。例如，改变指令集以减少指令数可能会导致组织结构的时钟周期时间变慢或 CPI 变高，从而抵消了指令数上的改进。同样，因为 CPI 取决于执行的指令类型，执行最少指令数的代码可能不是最快的。

| 性能的组成部分 | 测量单位 |
| :--- | :--- |
| 程序的 CPU 执行时间 | 秒/程序 |
| 指令数 | 程序执行的指令数 |
| 每条指令的时钟周期数 (CPI) | 每条指令的平均时钟周期数 |
| 时钟周期时间 | 秒/时钟周期 |

**图 1.15 性能的基本组成部分以及各自的测量方式。**

我们如何确定性能方程中这些因素的值？
我们可以通过运行程序来测量 CPU 执行时间，而时钟周期时间通常作为计算机文档的一部分发布。
指令数和 CPI 可能更难获得。
当然，如果我们知道时钟频率和 CPU 执行时间，我们只需要知道指令数或 CPI 中的一个就可以确定另一个。
我们可以使用分析执行的软件工具或使用架构模拟器来测量指令数。
或者，我们可以使用硬件计数器，大多数处理器都包含这些计数器，来记录各种测量值，包括执行的指令数、平均 CPI，以及通常的性能损失来源。
由于指令数取决于架构，而不是具体的实现，我们可以在不了解实现的所有细节的情况下测量指令数。
然而，CPI 取决于计算机中的各种设计细节，包括存储系统和处理器结构（我们将在第 4 章和第 5 章中看到），以及应用程序中执行的指令类型组合。
因此，CPI 因应用程序而异，也因同一指令集的不同实现而异。

\--- PAGE 64 ---

1.6 性能
39
上述例子显示了仅使用一个因素（指令数）来评估性能的危险。
在比较两台计算机时，您必须查看所有三个组成部分，它们共同构成了执行时间。
如果某些因素相同，如此例中的时钟频率，则可以通过比较所有不相同的因素来确定性能。
由于 CPI 因指令混合而异，因此即使时钟频率相等，也必须比较指令数和 CPI。
本章末尾的几个练习要求您评估一系列影响时钟频率、CPI 和指令数的计算机和编译器增强功能。
在 1.10 节中，我们将研究一种常见的性能测量方法，该方法不包含所有项，因此可能具有误导性。
**指令混合** 衡量一个或多个程序中指令的动态频率。

> **理解程序性能**
>
> 程序的性能取决于算法、语言、编译器、体系结构和实际硬件。下表总结了这些组件如何影响 CPU 性能方程中的因素。
>
> **性能**

| 硬件或软件组件 | 影响什么？ | 如何影响？ |
| :--- | :--- | :--- |
| 算法 | 指令数, CPI | 算法决定了执行的源程序指令数量，从而决定了执行的处理器指令数量。算法也可能通过偏爱较慢或较快的指令来影响 CPI。例如，如果算法使用更多的除法，它将倾向于有较高的 CPI。 |
| 编程语言 | 指令数, CPI | 编程语言肯定会影响指令数，因为语言中的语句被翻译成处理器指令，这决定了指令数。语言也可能因为其特性而影响 CPI；例如，一个对数据抽象有强大支持的语言（如 Java）将需要间接调用，这将使用 CPI 较高的指令。 |
| 编译器 | 指令数, CPI | 编译器的效率影响指令数和每条指令的平均周期数，因为编译器决定了源语言指令到计算机指令的翻译。编译器的作用可能非常复杂，并以多种方式影响 CPI。 |
| 指令集架构 | 指令数, 时钟频率, CPI | 指令集架构影响 CPU 性能的所有三个方面，因为它影响一个功能所需的指令、每条指令的周期成本以及处理器的整体时钟频率。 |

**阐述：** 虽然您可能期望最小的 CPI 是 1.0，但我们将在第 4 章中看到，一些处理器每个时钟周期可以取指并执行多条指令。
为了反映这种方法，一些设计者将 CPI 反转，谈论 IPC，即每时钟周期的指令数。
如果一个处理器平均每个时钟周期执行两条指令，那么它的 IPC 为 2，因此 CPI 为 0.5。

\--- PAGE 65 ---

40
第 1 章 计算机抽象与技术
**阐述：** 尽管时钟周期时间传统上是固定的，但为了节省能源或临时提升性能，今天的处理器可以改变它们的时钟频率，所以我们需要使用一个程序的平均时钟频率。
例如，Intel Core i7 会临时将时钟频率提高约 10%，直到芯片变得过热。
英特尔称之为 Turbo 模式。

> **自测**
>
> 一个用 Java 编写的给定应用程序在台式机处理器上运行需要 15 秒。
> 一个新的 Java 编译器发布了，它只需要旧编译器 0.6 倍的指令数。
> 不幸的是，它将 CPI 增加了 1.1 倍。我们能期望使用这个新编译器的应用程序运行多快？
>
> 从以下三个选项中选择正确答案：
>
> a. $\\frac{15 \\times 0.6}{1.1} = 8.2 \\text{ 秒}$
>
> b. $15 \\times 0.6 \\times 1.1 = 9.9 \\text{ 秒}$
>
> c. $\\frac{1.5 \\times 1.1}{0.6} = 27.5 \\text{ 秒}$
> **1.7**
> **功耗墙**
> 图 1.16 显示了 30 年来八代英特尔微处理器时钟频率和功耗的增长。
> 几十年来，时钟频率和功耗都迅速增长，然后最近趋于平缓。
> 它们共同增长的原因是它们是相关的，而它们最近放缓的原因是我们遇到了为商用微处理器散热的实际功耗极限。

**图 1.16** 八代英特尔 x86 微处理器在 30 年间的时钟频率和功耗。奔腾 4 在时钟频率和功耗上有了显著的提升，但在性能上的提升则不那么明显。Prescott 的散热问题导致奔腾 4 产品线被放弃。酷睿 2 系列回归到更简单的流水线，具有更低的时钟频率和每个芯片多个处理器。酷睿 i5 的流水线也沿袭了这一思路。

\--- PAGE 66 ---

1.7 功耗墙
尽管功率为我们能冷却的设备设定了上限，但在后 PC 时代，真正宝贵的资源是能源。
在个人移动设备中，电池寿命的重要性可能超过性能，而仓库级计算机的架构师们则试图降低为 10 万台服务器供电和冷却的成本，因为在这个规模上成本很高。
就像用秒来衡量时间比用 MIPS（见 1.10 节）这样的速率来评估程序性能更安全一样，用焦耳这个能量单位比用瓦特（焦耳/秒）这样的功率速率来衡量更好。
集成电路的主流技术称为 CMOS（互补金属氧化物半导体）。
对于 CMOS，能耗的主要来源是所谓的动态能耗——即晶体管从 0 切换到 1 以及反之亦然时消耗的能量。
动态能耗取决于每个晶体管的电容负载和施加的电压：
$$\text{能量} \propto \text{电容负载} \times \text{电压}^2$$
这个方程是在 $0 \\rightarrow 1 \\rightarrow 0$ 或 $1 \\rightarrow 0 \\rightarrow 1$ 逻辑转换期间一个脉冲的能量。
单次转换的能量则是
$$\text{能量} \propto \frac{1}{2} \times \text{电容负载} \times \text{电压}^2$$
每个晶体管所需的功率就是一次转换的能量与转换频率的乘积：
$$\text{功率} \propto \frac{1}{2} \times \text{电容负载} \times \text{电压}^2 \times \text{切换频率}$$
切换频率是时钟频率的函数。每个晶体管的电容负载是连接到一个输出的晶体管数量（称为扇出）和决定导线和晶体管电容的技术的函数。
关于图 1.16，时钟频率如何能增长 1000 倍，而功耗只增加 30 倍？
能量和功率可以通过降低电压来减少，这在每一代新技术中都会发生，而功率是电压的平方的函数。
通常，每一代电压降低约 15%。在 20 年间，电压从 5V 降到了 1V，这就是为什么功耗只增加了 30 倍。
**示例**
**相对功率**
假设我们开发了一款新的、更简单的处理器，其电容负载是更复杂的旧处理器的 85%。
进一步假设，它可以调整电压，使其电压比处理器 B 降低 15%，这导致频率降低 15%。
这对动态功率有什么影响？
41

\--- PAGE 67 ---

42
**答案**
第 1 章 计算机抽象与技术
$$\frac{\text{功率}_{\text{新}}}{\text{功率}_{\text{旧}}} = \frac{(\text{电容负载} \times 0.85) \times (\text{电压} \times 0.85)^2 \times (\text{切换频率} \times 0.85)}{\text{电容负载} \times \text{电压}^2 \times \text{切换频率}}$$
因此，功率比是
$$0.85 \times 0.85^2 \times 0.85 = 0.85^4 = 0.52$$
因此，新处理器使用的功率约为旧处理器的一半。
现代的问题是，进一步降低电压似乎会使晶体管漏电过多，就像无法完全关闭的水龙头。
即使在今天，服务器芯片中约 40% 的功耗是由于漏电。
如果晶体管开始漏得更多，整个过程可能会变得难以控制。
为了解决功耗问题，设计者们已经安装了大型设备来增加散热，并在给定的时钟周期内关闭芯片中未使用的部分。
尽管有许多更昂贵的方法来冷却芯片，从而将其功率提高到比如 300 瓦，但这些技术对于个人电脑甚至服务器来说通常成本太高，更不用说个人移动设备了。
由于计算机设计者撞上了一堵功耗墙，他们需要一条新的前进道路。
他们选择了一条与他们前 30 年设计微处理器不同的道路。
**阐述：** 尽管动态能耗是 CMOS 中能耗的主要来源，但静态能耗也会发生，因为它是由即使在晶体管关闭时也会流动的泄漏电流引起的。
在服务器中，泄漏通常占能耗的 40%。
因此，增加晶体管的数量会增加功耗，即使晶体管总是关闭的。
各种设计技术和技术创新正在被用来控制泄漏，但很难进一步降低电压。
**阐述：** 功率对集成电路来说是一个挑战，原因有二。
首先，功率必须被引入并分布在芯片周围；
现代微处理器仅用于供电和接地就使用了数百个引脚！
同样，芯片互连的多个层次也仅用于向芯片部分供电和接地。
其次，功率以热量的形式耗散，必须被移除。
服务器芯片可以消耗超过 100 瓦的功率，冷却芯片和周围系统是仓库规模计算机的一项主要开销（见第 6 章）。

\--- PAGE 68 ---

1.8 巨变：从单处理器到多处理器的转变
43
**1.8**
**巨变：从单处理器到多处理器的转变**
功耗限制迫使微处理器的设计发生了巨大变化。
图 1.17 显示了台式机微处理器程序响应时间的改善情况。
自 2002 年以来，增长率已从每年 1.5 倍放缓至每年 1.2 倍。
从 2006 年起，所有台式机和服务器公司不再继续减少单个处理器上运行的一个程序的响应时间，而是开始出货每个芯片带有多个处理器的微处理器，其好处通常更多地体现在吞吐量而非响应时间上。
为了减少“处理器”和“微处理器”这两个词之间的混淆，公司将处理器称为“核心”，而这类微处理器通常被称为多核微处理器。
因此，“四核”微处理器是一个包含四个处理器或四个核心的芯片。
在过去，程序员可以依赖硬件、架构和编译器的创新，每 18 个月就能让他们的程序性能翻倍，而无需更改一行代码。
如今，为了让程序员在响应时间上获得显著提升，他们需要重写程序以利用多个处理器。
此外，为了获得在新微处理器上运行更快的历史性好处，随着核心数量的增加，程序员将不得不继续提高他们代码的性能。
为了加强软硬件系统如何协同工作，我们在全书中使用了“硬件/软件接口”这个特殊部分，第一个部分如下所示。
这些元素总结了在这个关键接口上的重要见解。
直到目前，大多数软件就像为独奏家写的音乐；有了当前这一代芯片，我们对二重奏、四重奏和其他小型合奏有了一点经验；但为大型管弦乐队和合唱团谱曲则是一种不同的挑战。—— Brian Hayes, 《在并行宇宙中计算》, 2007。
**并行**

> **硬件/软件接口**
>
> 并行性在计算性能中一直至关重要，但它通常是隐藏的。
> 第 4 章将解释流水线技术，这是一种通过重叠指令执行来加快程序运行的优雅技术。
> 这种优化是**指令级并行**的一个例子，其中硬件的并行特性被抽象掉了，因此程序员和编译器可以将硬件视为顺序执行指令。
>
> 强迫程序员意识到并行硬件并重写他们的程序以实现并行，一直是计算机体系结构的“第三轨”，因为过去依赖这种行为改变的公司都失败了（见 6.15 节）。从这个历史角度来看，整个 IT 行业都把未来押注在程序员最终会成功转向显式并行编程上，这令人吃惊。
> **流水线**

\--- PAGE 69 ---

性能 (对比 VAX-11/780)
44
第 1 章 计算机抽象与技术

**图 1.17** 自 20 世纪 80 年代中期以来的处理器性能增长。该图表以 SPECint 基准测试衡量的、相对于 VAX 11/780 的性能为基准绘制。在 80 年代中期之前，处理器性能的增长主要由技术驱动，平均每年增长约 25%。此后增长到约 52%，这归功于更先进的体系结构和组织思想。自 80 年代中期以来 52% 的年性能提升意味着，2002 年的性能比如果保持在 25% 的增长率下要高出约七倍。自 2002 年以来，功耗、可用的指令级并行性和长内存延迟的限制减缓了单处理器的性能，最近约为每年 22%。
为什么程序员写显式并行程序这么难？
第一个原因是，并行编程从定义上讲就是性能编程，这增加了编程的难度。
程序不仅需要正确，解决一个重要问题，并为调用它的人或其他程序提供一个有用的接口；
程序还必须快。否则，如果你不需要性能，就写一个顺序程序好了。
第二个原因是，对于并行硬件来说，“快”意味着程序员必须划分一个应用程序，使得每个处理器在同一时间有大致相同的工作量，并且调度和协调的开销不会浪费掉并行性带来的潜在性能优势。
打个比方，假设任务是写一篇新闻报道。
八个记者同时写同一篇报道，理论上可以快八倍。
为了达到这个提速，需要将任务分解，让每个记者在同一时间都有事可做。
因此，我们必须安排子任务。如果出了任何差错，只要有一个记者比其他七个花的时间长，那么有八个作者的好处就会减少。
因此，我们必须平衡

\--- PAGE 70 ---

1.8 巨变：从单处理器到多处理器的转变
为了获得期望的加速效果，负载需要均匀分配。另一个风险是，如果记者们需要花很多时间互相交流来写各自的部分，效果也会打折扣。
如果故事的某个部分，比如结论，必须等到所有其他部分都完成后才能写，你也会达不到目标。
因此，必须注意减少通信和同步开销。
对于这个类比和并行编程来说，挑战都包括调度、负载均衡、同步时间以及各方之间的通信开销。
正如你可能猜到的，对于报纸故事来说，记者越多，挑战就越严峻；对于并行编程来说，处理器越多，挑战也越严峻。
为了反映行业的这一巨变，本版书接下来的五章每章都有一节讨论并行革命对该章的影响：
■ 第 2 章，第 2.11 节：并行性与指令：同步。通常独立的并行任务需要在某些时候进行协调，比如告知它们已经完成了工作。
本章解释了多核处理器用于同步任务的指令。
■ 第 3 章，第 3.6 节：并行性与计算机算术：子字并行。
也许最容易构建的并行形式是并行计算元素，例如当两个向量相乘时。
子字并行利用摩尔定律提供的资源，提供更宽的算术单元，可以同时对多个操作数进行操作。
■ 第 4 章，第 4.10 节：通过指令实现并行。鉴于显式并行编程的困难，20 世纪 90 年代在让硬件和编译器发现隐式并行方面投入了巨大努力，最初是通过流水线。
本章描述了一些这些激进的技术，包括并发取指和执行多条指令，以及猜测决策结果，并使用预测来推测性地执行指令。
■ 第 5 章，第 5.10 节：并行性与存储器层次结构：缓存一致性。
降低通信成本的一种方法是让所有处理器使用相同的地址空间，这样任何处理器都可以读写任何数据。
鉴于今天所有处理器都使用缓存来将数据的临时副本保存在处理器附近的更快内存中，可以想象，如果与每个处理器关联的缓存对共享数据的值不一致，并行编程会更加困难。
本章描述了保持所有缓存中数据一致的机制。
■ 第 5 章，第 5.11 节：并行性与存储器层次结构：廉价磁盘冗余阵列。
本节描述了如何通过同时使用多个磁盘来提供更高的吞吐量，这是廉价磁盘冗余阵列 (RAID) 的最初灵感。
RAID 真正受欢迎的原因是通过包含适度数量的冗余磁盘提供了更高的可靠性。
本节解释了各种 RAID 级别在性能、成本和可靠性方面的差异。
**摩尔定律**
**流水线**
**预测**
**层次结构**
45

\--- PAGE 71 ---

46
第 1 章 计算机抽象与技术
**并行**
我原以为（计算机）会像书一样，成为一个普遍适用的想法。但我没想到它会发展得那么快，因为我没有预见到我们能在一个芯片上集成那么多部件。晶体管的出现出乎意料。一切都比我们预期的要快得多。—— J. Presper Eckert，ENIAC 的共同发明者，1991 年谈话
除了这些章节，还有一整章关于并行处理。
第 6 章更详细地探讨了并行编程的挑战；
介绍了共享寻址和显式消息传递这两种截然不同的通信方法；
描述了一种更易于编程的受限并行模型；讨论了并行处理器基准测试的困难；
为多核微处理器引入了一个新的简单性能模型；最后，使用这个模型描述和评估了四个多核微处理器的例子。
如上所述，第 3 章至第 6 章使用矩阵向量乘法作为一个贯穿的例子，展示每种并行性如何能显著提高性能。
附录 B 描述了一种日益流行的硬件组件，它与台式电脑一同提供，即图形处理单元 (GPU)。
GPU 最初是为了加速图形而发明的，现在正成为一个独立的编程平台。
正如你可能预料到的，鉴于这个时代，GPU 依赖于并行性。
附录 B 描述了 NVIDIA GPU，并重点介绍了其并行编程环境的部分内容。
**1.9**
**实例：基准测试 Intel Core i7**
每章都有一个名为“实例”的部分，将书中的概念与您可能每天使用的计算机联系起来。
这些部分涵盖了现代计算机的底层技术。对于第一个“实例”部分，我们来看看集成电路是如何制造的，以及性能和功率是如何测量的，以 Intel Core i7 为例。
**工作负载** 在计算机上运行的一组程序，它要么是用户运行的实际应用程序集合，要么是为了近似这种混合而从真实程序构建的。典型的工作负载指定了程序和相对频率。
**加速常见情况**
**SPEC CPU 基准测试**
一个日复一日运行相同程序的计算机用户，将是评估新计算机的完美人选。
运行的程序集将构成一个工作负载。要评估两个计算机系统，用户只需比较工作负载在两台计算机上的执行时间。
然而，大多数用户并非处于这种情况。相反，他们必须依赖其他方法来衡量候选计算机的性能，希望这些方法能反映出计算机在用户的工作负载下的表现。
这种替代方法通常是通过使用一组基准测试——专门选择用来衡量性能的程序——来评估计算机。
基准测试构成了一个用户希望能够预测实际工作负载性能的工作负载。
如我们上面所指出的，要使常见情况快速，你首先需要准确地知道哪种情况是常见的，所以基准测试在计算机体系结构中扮演着关键的角色。
**基准测试** 为比较计算机性能而选择的程序。
SPEC (系统性能评估合作组织) 是一个由多家计算机供应商资助和支持的组织，旨在为现代计算机系统创建标准的基准测试集。
1989 年，SPEC 最初创建了一个专注于处理器性能的基准测试集（现在称为 SPEC89），该基准测试集已经发展了五代。

-----

以上是第 52-71 页的翻译。请您先复制或导出。

完成后，请告诉我，我们是否要继续翻译下一部分（第 72-91 页）？

好的，我们继续。

这是第三部分，包含 **第 72 页到第 91 页** 的翻译内容。

-----

\--- PAGE 72 ---

1.9 实例：基准测试 Intel Core i7
47
最新的版本是 SPEC CPU2006，它包含一组 12 个整数基准测试 (CINT2006) 和 17 个浮点基准测试 (CFP2006)。
整数基准测试从 C 编译器的一部分到一个国际象棋程序，再到一个量子计算机模拟，种类繁多。
浮点基准测试包括用于有限元建模的结构化网格代码，用于分子动力学的粒子方法代码，以及用于流体动力学的稀疏线性代数代码。
图 1.18 描述了 SPEC 整数基准测试及其在 Intel Core i7 上的执行时间，并显示了解释执行时间的因素：指令数、CPI 和时钟周期时间。
注意，CPI 的变化超过了 5 倍。
为了简化计算机的市场营销，SPEC 决定报告一个单一的数字来总结所有 12 个整数基准测试。
用参考处理器的执行时间除以被评估计算机的执行时间来对执行时间测量进行归一化；
这种归一化产生了一个称为 SPECratio 的度量，其优点是数值越大表示性能越快。
也就是说，SPECratio 是执行时间的倒数。
CINT2006 或 CFP2006 的总结测量值是通过取 SPECratios 的几何平均值获得的。

| 描述 | 名称 | 指令数 (十亿) | CPI | 时钟周期时间 (ns) | 执行时间 (s) | 参考时间 (s) | SPECratio |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 解释型字符串处理 | perl | 2,252 | 0.60 | 0.376 | 508 | 9,770 | 19.2 |
| 块排序压缩 | bzip2 | 2,390 | 0.70 | 0.376 | 629 | 9,650 | 15.4 |
| GNU C 编译器 | gcc | 794 | 1.20 | 0.376 | 358 | 8,050 | 22.5 |
| 组合优化 | mcf | 221 | 2.66 | 0.376 | 221 | 9,120 | 41.2 |
| 围棋游戏 (AI) | go | 1,274 | 1.10 | 0.376 | 527 | 10,490 | 19.9 |
| 搜索基因序列 | hmmer | 2,616 | 0.60 | 0.376 | 590 | 9,330 | 15.8 |
| 国际象棋游戏 (AI) | sjeng | 1,948 | 0.80 | 0.376 | 586 | 12,100 | 20.7 |
| 量子计算机模拟 | libquantum | 659 | 0.44 | 0.376 | 109 | 20,720 | 190.0 |
| 视频压缩 | h264avc | 3,793 | 0.50 | 0.376 | 713 | 22,130 | 31.0 |
| 离散事件模拟库 | omnetpp | 367 | 2.10 | 0.376 | 290 | 6,250 | 21.5 |
| 游戏/寻路 | astar | 1,250 | 1.00 | 0.376 | 470 | 7,020 | 14.9 |
| XML 解析 | xalancbmk | 1,045 | 0.70 | 0.376 | 275 | 6,900 | 25.1 |
| **几何平均值** | | | | | | | **25.7** |

**图 1.18** 在 2.66 GHz Intel Core i7 920 上运行的 SPECINTC2006 基准测试。正如第 36 页的公式所解释的，执行时间是此表中三个因素的乘积：指令数（以十亿为单位），每指令时钟周期数 (CPI)，以及时钟周期时间（以纳秒为单位）。SPECratio 只是参考时间（由 SPEC 提供）除以测得的执行时间。被引用的单个数字 SPECINTC2006 是 SPECratios 的几何平均值。

\--- PAGE 73 ---

48
第 1 章 计算机抽象与技术
**阐述：** 当使用 SPECratios 比较两台计算机时，应用几何平均值，这样无论使用哪台计算机来归一化结果，它都会给出相同的相对答案。
如果我们用算术平均值来平均归一化的执行时间值，结果会因我们选择作为参考的计算机而异。
几何平均值的公式是
$$\sqrt[n]{\prod_{i=1}^{n} \text{执行时间比率}_i}$$
其中，执行时间比率$\_i$ 是第 i 个程序（工作负载中总共有 n 个程序）的执行时间，已对参考计算机进行归一化，而
$$\prod_{i=1}^{n} a_i \text{ 表示乘积 } a_1 \times a_2 \times \dots \times a_n$$
**SPEC 功耗基准测试**
鉴于能源和功率日益重要，SPEC 增加了一个衡量功率的基准测试。
它报告服务器在不同工作负载水平下（分为 10% 的增量）一段时间内的功耗。
图 1.19 显示了使用与上述类似的 Intel Nehalem 处理器的服务器的结果。

| 目标负载 % | 性能 (ssj\_ops) | 平均功率 (瓦特) |
| :--- | :--- | :--- |
| 100% | 865,618 | 258 |
| 90% | 786,688 | 242 |
| 80% | 698,051 | 224 |
| 70% | 607,826 | 204 |
| 60% | 521,391 | 185 |
| 50% | 436,757 | 170 |
| 40% | 345,919 | 157 |
| 30% | 262,071 | 146 |
| 20% | 176,061 | 135 |
| 10% | 86,784 | 121 |
| 0% | 0 | 80 |
| **总和** | **4,787,166** | **1,922** |
| **Σssj\_ops / Σpower =** | | **2,490** |

**图 1.19** 在双插槽 2.66 GHz Intel Xeon X5650（配备 16 GB DRAM 和一个 100 GB SSD 磁盘）上运行的 SPECpower\_ssj2008。
SPECpower 从另一个用于 Java 商业应用的 SPEC 基准测试 (SPECJBB2005) 开始，该基准测试不仅考验处理器、缓存和主存，还考验 Java 虚拟机、编译器、垃圾回收器和部分操作系统。
性能以吞吐量来衡量，单位是每秒的业务操作数。
同样，为了简化计算机的市场营销，SPEC

\--- PAGE 74 ---

1.10 谬误与陷阱
49
将这些数字归结为一个数字，称为“整体 ssj\_ops 每瓦特”。这个单一总结性指标的公式是
$$\text{整体 ssj\_ops 每瓦特} = \left( \sum_{i=0}^{10} \text{ssj\_ops}_i \right) / \left( \sum_{i=0}^{10} \text{功率}_i \right)$$
其中 ssj\_ops$\_i$ 是每个 10% 增量下的性能，而 power$\_i$ 是每个性能水平下消耗的功率。
**1.10 谬误与陷阱**
“谬误与陷阱”部分的目的（每章都有）是解释一些您可能会遇到的普遍持有的误解。
我们称它们为谬误。在讨论谬误时，我们试图给出一个反例。
我们也讨论陷阱，或容易犯的错误。通常陷阱是在有限范围内成立的原则的概括。
这些部分的目的是帮助您避免在您可能设计或使用的计算机中犯这些错误。
成本/性能的谬误和陷阱已经困住了许多计算机架构师，包括我们。
因此，本节不乏相关例子。我们从一个困住许多设计师并揭示计算机设计中重要关系的陷阱开始。
**陷阱：期望改进计算机的某一方面会使整体性能提高与改进大小成比例的量。**
“加速常见情况”这个伟大的思想有一个令人沮丧的推论，它困扰着硬件和软件的设计者。
它提醒我们，改进的机会受到事件消耗时间的多少影响。
一个简单的设计问题很好地说明了这一点。假设一个程序在一台计算机上运行 100 秒，其中乘法运算占用了 80 秒。
如果我希望我的程序运行速度快五倍，我需要将乘法的速度提高多少？
做出改进后程序的执行时间由以下简单的方程给出，即阿姆达尔定律：
$$\text{改进后执行时间} = \frac{\text{受改进影响的执行时间}}{\text{改进量}} + \text{未受影响的执行时间}$$
科学必须始于神话，以及对神话的批判。——卡尔·波普尔爵士，《科学哲学》，1957
**加速常见情况**
**阿姆达尔定律 (Amdahl's Law)** 一条规则，指出通过某项改进可能获得的性能提升，受限于被改进特性被使用的程度。它是收益递减法则的量化版本。
对于这个问题：
$$\text{改进后执行时间} = \frac{80 \text{ 秒}}{n} + (100 - 80 \text{ 秒})$$

\--- PAGE 75 ---

50
第 1 章 计算机抽象与技术
因为我们希望性能快五倍，所以新的执行时间应该是 20 秒，得到
$$20 \text{ 秒} = \frac{80 \text{ 秒}}{n} + 20 \text{ 秒}$$$$0 = \frac{80 \text{ 秒}}{n}$$
也就是说，如果乘法只占工作负载的 80%，我们无法通过任何程度的增强乘法来实现五倍的性能提升。
通过某项改进可能获得的性能提升，受限于被改进特性被使用的程度。
在日常生活中，这个概念也产生了我们所说的收益递减法则。
我们可以使用阿姆达尔定律来估计性能改进，当我们知道某个功能消耗的时间及其潜在的加速比时。
阿姆达尔定律与 CPU 性能方程一起，是评估可能增强的便捷工具。
阿姆达尔定律在练习中有更详细的探讨。
阿姆达尔定律也用于论证并行处理器数量的实际限制。
我们在第 6 章的谬误与陷阱部分探讨了这一论点。
**谬误：低利用率的计算机功耗很小。**
功率效率在低利用率时很重要，因为服务器工作负载是变化的。
例如，谷歌仓库级计算机中服务器的利用率在大多数时间在 10% 到 50% 之间，而在 100% 的时间不到 1%。
即使经过 5 年的学习如何很好地运行 SPECpower 基准测试，2012 年结果最好的专门配置的计算机在 10% 负载下仍使用峰值功率的 33%。
现场未为 SPECpower 基准测试配置的系统肯定更差。
由于服务器的工作负载变化，但使用了大部分峰值功率，Luiz Barroso 和 Urs Hölzle [2007] 认为我们应该重新设计硬件以实现“能量成比例计算”。
如果未来的服务器在 10% 的工作负载下使用峰值功率的 10%，我们就可以降低数据中心的电费，并在日益关注 $CO\_2$ 排放的时代成为优秀的企业公民。
**谬误：为性能设计和为能效设计是无关的目标。**
由于能量是功率随时间的累积，因此，即使优化本身在使用时会消耗多一点能量，但花费更少时间的硬件或软件优化通常也能在整体上节省能源。
一个原因是，在程序运行时，计算机的其余部分都在消耗能量，所以即使优化部分多用了一点能量，减少的时间也能节省整个系统的能量。
**陷阱：使用性能方程的一个子集作为性能指标。**
我们已经警告过，仅根据时钟频率、指令数或 CPI 中的一个来预测性能是危险的。
另一个常见的错误是仅使用这三个因素中的两个来比较性能。虽然使用

\--- PAGE 76 ---

1.10 谬误与陷阱
51
三个因素中的两个在有限的背景下可能是有效的，但这个概念也很容易被滥用。
事实上，几乎所有提出的替代使用时间作为性能指标的方法最终都导致了误导性的声明、扭曲的结果或不正确的解释。
时间的一种替代方案是 MIPS (每秒百万条指令)。对于给定的程序，MIPS 只是
$$\text{MIPS} = \frac{\text{指令数}}{\text{执行时间} \times 10^6}$$
由于 MIPS 是一个指令执行率，MIPS 与执行时间成反比；
更快的计算机有更高的 MIPS 评级。关于 MIPS 的好消息是它易于理解，更快的计算机意味着更大的 MIPS，这符合直觉。
使用 MIPS 作为比较计算机的度量有三个问题。
首先，MIPS 指定了指令执行率，但没有考虑指令的能力。
我们不能使用 MIPS 来比较具有不同指令集的计算机，因为指令数肯定会不同。
其次，MIPS 在同一台计算机上的不同程序之间是变化的；因此，一台计算机不能有一个单一的 MIPS 评级。
例如，通过代入执行时间，我们可以看到 MIPS、时钟频率和 CPI 之间的关系：
$$\text{MIPS} = \frac{\text{指令数}}{\frac{\text{指令数} \times \text{CPI}}{\text{时钟频率}} \times 10^6} = \frac{\text{时钟频率}}{\text{CPI} \times 10^6}$$
在图 1.18 中，Intel Core i7 计算机上 SPEC CPU2006 的 CPI 变化了 5 倍以上，所以 MIPS 也是如此。
最后，也是最重要的，如果一个新程序执行了更多的指令，但每条指令都更快，MIPS 的变化可能与性能无关！
**每秒百万条指令 (MIPS)** 基于百万条指令数量的程序执行速度测量。MIPS 计算为指令数除以执行时间与 $10^6$ 的乘积。

> **自测**
>
> 考虑一个程序的以下性能测量：
>
> | 测量 | 计算机 A | 计算机 B |
> | :--- | :--- | :--- |
> | 指令数 | 100 亿 | 80 亿 |
> | 时钟频率 | 4 GHz | 4 GHz |
> | CPI | 1.0 | 1.1 |
>
> a. 哪台计算机的 MIPS 评级更高？
> b. 哪台计算机更快？

\--- PAGE 77 ---

52
第 1 章 计算机抽象与技术
ENIAC 配备了 18,000 个真空管，重 30 吨，而未来的计算机可能只有 1,000 个真空管，也许只重 1.5 吨。——《大众机械》，1949 年 3 月
**抽象**
**1.11 结论**
尽管很难准确预测未来计算机将达到何种成本/性能水平，但可以肯定的是，它们将比今天好得多。
为了参与这些进步，计算机设计者和程序员必须理解更广泛的问题。
硬件和软件设计者都以分层的方式构建计算机系统，每一层都对上层隐藏细节。
抽象这个伟大的思想是理解当今计算机系统的基础，但这并不意味着设计者可以局限于只了解单一的抽象。
也许最重要的抽象例子是硬件和低级软件之间的接口，称为指令集架构。
保持指令集架构不变，使得该架构的许多实现——可能在成本和性能上有所不同——能够运行相同的软件。
不利的一面是，该架构可能会阻止引入需要改变接口的创新。
有一种可靠的方法来确定和报告性能，即使用真实程序的执行时间作为度量。
这个执行时间与我们可以进行的其他重要测量通过以下方程相关联：
$$\frac{\text{秒}}{\text{程序}} = \frac{\text{指令数}}{\text{程序}} \times \frac{\text{时钟周期数}}{\text{指令}} \times \frac{\text{秒}}{\text{时钟周期}}$$
我们将多次使用这个方程及其构成因素。
但请记住，这些因素单独并不能决定性能：只有它们的乘积，即执行时间，才是性能的可靠度量。

> **大局观**
>
> 执行时间是唯一有效且无可指摘的性能度量。许多其他指标已被提出并发现不足。有时这些指标从一开始就有缺陷，因为它们不反映执行时间；其他时候，一个在有限范围内合理的指标被扩展并超出该范围使用，或者没有附加必要的澄清使其有效。

\--- PAGE 78 ---

1.11 结论
53
现代处理器的关键硬件技术是硅。与理解集成电路技术同等重要的是，理解由摩尔定律预测的技术变革的预期速率。
**摩尔定律**
虽然硅推动了硬件的快速进步，但计算机组织的新思想也提高了性价比。
两个关键思想是利用程序中的并行性（如今通常通过多个处理器）和利用对存储器层次结构的访问局部性（通常通过缓存）。
**层次结构**
**并行**
能效已经取代芯片面积，成为微处理器设计中最关键的资源。
在试图提高性能的同时节约功耗，迫使硬件行业转向多核微处理器，从而要求软件行业转向并行硬件编程。
并行性现在是性能的必要条件。
计算机设计一直以成本和性能来衡量，以及其他重要因素，如能源、可靠性、拥有成本和可扩展性。
尽管本章重点关注成本、性能和能源，但最好的设计将在所有因素之间为给定市场找到适当的平衡。
**本书路线图**
在这些抽象的底层是计算机的五个经典组件：数据通路、控制器、存储器、输入和输出（参考图 1.5）。
这五个组件也作为本书其余章节的框架：
■ **数据通路：** 第 3 章，第 4 章，第 6 章，以及附录 B
■ **控制器：** 第 4 章，第 6 章，以及附录 B
■ **存储器：** 第 5 章
■ **输入：** 第 5 章和第 6 章
■ **输出：** 第 5 章和第 6 章
如上所述，第 4 章描述了处理器如何利用隐式并行性，第 6 章描述了作为并行革命核心的显式并行多核微处理器，附录 B 描述了高度并行的图形处理器芯片。
第 5 章描述了存储器层次结构如何利用局部性。第 2 章描述了指令集——编译器和计算机之间的接口——并强调了编译器和编程语言在使用指令集特性中的作用。
第 3 章描述了计算机如何处理算术数据。附录 A 介绍了逻辑设计。

\--- PAGE 79 ---

54
第 1 章 计算机抽象与技术
一个活跃的科学领域就像一个巨大的蚁丘；个体几乎消失在相互碰撞、传递信息、以光速传播信息的思想海洋中。——刘易斯·托马斯，《细胞的生命》中的“自然科学”，1974年
**1.12-**
**历史观点与延伸阅读**
对于书中的每一章，都可以在本书配套的网站上找到一个专门讨论历史观点的部分。
我们可能会通过一系列计算机来追溯一个思想的发展，或者描述一些重要的项目，并且我们会提供参考资料，以备您有兴趣进一步探究。
本章的历史观点为本开篇章节中提出的一些关键思想提供了背景。
其目的是为您讲述技术进步背后的人类故事，并将成就置于其历史背景中。
通过研究过去，您可能能够更好地理解将塑造未来计算的力量。
每个在线的历史观点部分都以延伸阅读建议结尾，这些建议也在线上“延伸阅读”部分单独收集。
1.12 节的其余部分在线上。
**1.13 练习**
练习的相对时间评级在每个练习编号后的方括号中显示。
平均而言，一个评级为 [10] 的练习将花费您两倍于评级为 [5] 的练习的时间。
在尝试一个练习之前应该阅读的文本部分将用尖括号给出；
例如，\<§1.4\> 意味着您应该已经阅读了第 1.4 节“揭开面纱”，以帮助您解决这个练习。
1.1 [2] \<§1.1\> 除了十亿人使用的智能手机外，列出并描述四种其他类型的计算机。
1.2 [5] \<§1.2\> 计算机体系结构中的八个伟大思想与其他领域的思想相似。
将计算机体系结构中的八个思想，“为摩尔定律而设计”、“使用抽象简化设计”、“加速常见情况”、“通过并行提升性能”、“通过流水线提升性能”、“通过预测提升性能”、“存储器层次结构”和“通过冗余实现可靠性”与以下其他领域的思想进行匹配：
a. 汽车制造业的装配线
b. 悬索桥的缆索
c. 结合了风力信息的飞机和船舶导航系统。
d. 建筑物中的快速电梯

\--- PAGE 80 ---

1.12 历史观点与延伸阅读
54.e1
**-1.12-**
**历史观点与延伸阅读**
对于书中的每一章，都可以在网上找到一个专门的历史观点部分。
我们可能会通过一系列机器来追溯一个思想的发展，或者描述一些重要的项目，并且我们会提供参考资料，以备您有兴趣进一步探究。
本章的历史观点为其中提出的一些关键思想提供了背景。
其目的是为您讲述技术进步背后的人类故事，并将成就置于其历史背景中。
通过学习过去，您可能能够更好地理解将塑造未来计算的力量。
每个历史观点部分都以额外的阅读建议结尾，这些建议也在线上“延伸阅读”部分单独收集。
**第一台电子计算机**
J. Presper Eckert 和 John Mauchly 在宾夕法尼亚大学摩尔学院建造了被广泛认为是世界上第一台可操作的电子通用计算机。
这台名为 ENIAC（电子数值积分器和计算器）的机器由美国陆军资助，在第二次世界大战期间开始工作，但直到 1946 年才公之于众。ENIAC 是一台用于计算炮兵射表通用机器。
一个活跃的科学领域就像一个巨大的蚁丘；个体几乎消失在相互碰撞、传递信息、以光速传播信息的思想海洋中。——刘易斯·托马斯，《细胞的生命》中的“自然科学”，1974年
图 e1.12.1 显示了这台 U 形计算机，它长 80 英尺，高 8.5 英尺，宽数英尺。

**图 e1.12.1** ENIAC，世界上第一台通用电子计算机。

\--- PAGE 81 ---

54.e2
1.12 历史观点与延伸阅读
每个 20 位的 10 位寄存器长 2 英尺。
总共，ENIAC 使用了 18,000 个真空管。
在尺寸上，ENIAC 比今天建造的机器大了两个数量级，但它的速度却慢了八个多数量级，每秒执行 1900 次加法。
ENIAC 提供了条件跳转功能并且是可编程的，这清楚地将其与早期的计算器区分开来。
编程是通过手动插拔电缆和设置开关来完成的，数据则通过打孔卡输入。
典型计算的编程需要半小时到一整天的时间。
ENIAC 是一台通用机器，主要受限于少量存储和繁琐的编程。
1944 年，约翰·冯·诺依曼被 ENIAC 项目所吸引。
该小组希望改进程序的输入方式，并讨论了将程序作为数字存储；
冯·诺依曼帮助将这些想法具体化，并写了一份备忘录，提议制造一台名为 EDVAC（电子离散变量自动计算机）的存储程序计算机。
赫尔曼·戈德斯坦分发了这份备忘录，并署上了冯·诺依曼的名字，这让埃克特和莫奇利非常懊恼，因为他们的名字被省略了。
这份备忘录成为了常用术语“冯·诺依曼计算机”的基础。
几位计算机领域的早期先驱认为，这个术语给予了撰写思想的冯·诺依曼过多的荣誉，而给予了致力于机器的工程师埃克特和莫奇利过少的荣誉。
因此，这个术语在本书或在线章节的其他地方没有出现。
1946年，剑桥大学的莫里斯·威尔克斯访问了摩尔学院，参加了一系列关于电子计算机发展的讲座的后半部分。
当他回到剑桥时，威尔克斯决定启动一个项目，建造一台名为 EDSAC (电子延迟存储自动计算器) 的存储程序计算机。
EDSAC 于 1949 年开始工作，是世界上第一台全尺寸、可操作的存储程序计算机 [Wilkes, 1985]。
（1948 年在曼彻斯特大学建造的一个名为 Mark-I 的小型原型机，或许可以被称为第一台可操作的存储程序机器。）第 2.5 节解释了存储程序概念。
1947年，埃克特和莫奇利申请了电子计算机的专利。
摩尔学院的院长要求将专利权移交给大学，这可能促使埃克特和莫奇利决定离开。
他们的离开使得 EDVAC 项目陷入瘫痪，直到 1952 年才完成。
戈德斯坦于 1946 年离开，加入了普林斯顿高等研究院的冯·诺依曼。他们与亚瑟·伯克斯一起，根据之前写的备忘录发布了一份报告 [Burks et al., 1946]。
这篇论文在当时令人难以置信；今天读它，你永远猜不到这篇里程碑式的论文是 50 多年前写的，因为它讨论了现代计算机中见到的大多数架构概念。
这篇论文促成了朱利安·比奇洛建造的 IAS 机器。
它总共有 1024 个 40 位的字，速度大约是 ENIAC 的 10 倍。
该小组思考了机器的用途，发表了一系列报告，

\--- PAGE 82 ---

1.12 历史观点与延伸阅读
54.e3
并鼓励参观者。这些报告和参观者启发了许多新计算机的开发。
最近，关于约翰·阿塔纳索夫的工作存在一些争议，他在 20 世纪 40 年代初建造了一台小规模的电子计算机。
他在爱荷华州立大学设计的机器是一台专用计算机，从未完全投入使用。
莫奇利在建造 ENIAC 之前曾短暂拜访过阿塔纳索夫。
阿塔纳索夫机器的存在，加上 ENIAC 专利申请的延误（该工作是保密的，专利直到战后才能申请）以及冯·诺依曼的 EDVAC 论文的传播，被用来推翻埃克特-莫奇利专利。
尽管关于阿塔纳索夫角色的争议仍在继续，但埃克特和莫奇利通常被认为是建造了第一台可工作的、通用的电子计算机[Stern, 1980]。
另一个值得称赞的开创性计算机是康拉德·楚泽于 20 世纪 30 年代末和 40 年代初在德国制造的一台专用机器。
尽管楚泽已经准备好了一台可编程计算机的设计，但德国政府决定不资助超过 2 年的科学调查，因为官僚们预计战争会在那个期限内获胜。
在英吉利海峡对岸，第二次世界大战期间，建造了专用的电子计算机来解密截获的德国信息。
包括艾伦·图灵在内的布莱切利园团队于 1943 年建造了巨人计算机。这些机器直到 1970 年才被解密；
战后，该团队对商业化的英国计算机影响甚微。
在 ENIAC 的工作进行的同时，霍华德·艾肯正在哈佛大学建造一台名为 Mark-I 的机电计算机（这个名字后来被曼彻斯特大学用于其机器）。
他在 Mark-I 之后又制造了一台继电器机器 Mark-II，以及一对真空管机器 Mark-III 和 Mark-IV。
与早期的机器如 EDSAC（它为指令和数据使用单一存储器）相比，Mark-III 和 Mark-IV 为指令和数据有独立的存储器。
这些机器被存储程序计算机的倡导者视为反动派；
“哈佛架构”这个术语被创造出来，用以描述具有不同存储器的机器。
出于对历史的尊重，今天这个术语在不同的意义上使用，用以描述具有单一主存储器但为指令和数据提供独立缓存的机器。
旋风项目于 1947 年在麻省理工学院启动，旨在应用于实时雷达信号处理。
尽管它带来了几项发明，但其最重要的创新是磁芯存储器。
旋风拥有 2048 个 16 位字的磁芯存储器。磁芯作为主要存储技术服务了近 30 年。
**商业发展**
1947 年 12 月，埃克特和莫奇利成立了埃克特-莫奇利计算机公司。
他们的第一台机器 BINAC 是为诺斯罗普公司制造的，于 1949 年 8 月展示。经过一些财务困难后，他们的公司被雷明顿-兰德公司收购，在那里他们建造了 UNIVAC I（通用自动

\--- PAGE 83 ---

54.e4
1.12 历史观点与延伸阅读
计算机），旨在作为通用计算机销售（图 e1.12.2）。
UNIVAC I 最初于 1951 年 6 月交付，售价约 100 万美元，是第一台成功的商用计算机——共建造了 48 套系统！
这台早期的机器，连同许多其他引人入胜的计算机传说，都可以在加利福尼亚州山景城的计算机历史博物馆看到。

**图 1.12.2** UNIVAC I，美国第一台商用计算机。它正确预测了 1952 年总统选举的结果，但其最初的预测被扣发，因为专家们对使用如此早期的结果持怀疑态度。
IBM 一直从事打孔卡和办公自动化业务，但直到 1950 年才开始制造计算机。第一台 IBM 计算机 IBM 701 于 1952 年出货，最终售出 19 台。
在 20 世纪 50 年代初，许多人对计算机的未来持悲观态度，认为这些“高度专业化”机器的市场和机会非常有限。
1964年，在投资了50亿美元之后，IBM 以发布 System/360 做出了一个大胆的举动。
一位 IBM 发言人当时说：
在这次发布中，我们毫不谦虚。这是本公司有史以来最重要的产品发布。它不是任何以前意义上的计算机。它不是一个产品，而是一个产品线……其性能从计算机产品线的最低端一直延伸到最高端。

\--- PAGE 84 ---

1.12 历史观点与延伸阅读
54.e5

**图 e1.12.3** IBM System/360 计算机：40、50、65 和 75 型号均于 1964 年推出。这四款型号在成本和性能上相差近 10 倍；如果包括 20 和 30 型号（未显示），则差距扩大到 25 倍。仅处理器和平均大小内存的时钟频率、内存大小范围和大致价格为：(a) 40 型，1.6 MHz, 32 KB-256 KB, $225,000；(b) 50 型，2.0 MHz, 128 KB-256 KB, $550,000；(c) 65 型，5.0 MHz, 256 KB-1 MB, $1,200,000；以及 (d) 75 型，5.1 MHz, 256 KB-1 MB, $1,900,000。增加 I/O 设备通常会使价格增加 1.8 到 3.5 倍，价格较低的型号增加倍数更高。

**抽象**
将架构抽象的概念引入商业现实，IBM 宣布了 System/360 架构的六种实现，其价格和性能相差 25 倍。图 e1.12.3 显示了其中四种型号。
IBM 将其公司的命运押注于一个计算机家族的成功上，IBM 赢了。
System/360 及其后续产品主导了大型计算机市场。
大约一年后，数字设备公司 (DEC) 推出了 PDP-8，第一台商用小型计算机。
这台小型机器是低成本设计的突破，使 DEC 能够以低于 20,000 美元的价格提供一台计算机。
小型计算机是微处理器的先驱，英特尔于 1971 年发明了第一款微处理器——英特尔 4004。

\--- PAGE 85 ---

54.e6
1.12 历史观点与延伸阅读

**图 e1.12.4** Cray-1，1976 年宣布的首台商用向量超级计算机。这台机器有一个不同寻常的特点，即它既是科学应用中最快的计算机，也是这些应用中性价比最高的计算机。从顶部看，这台计算机像字母 C。Seymour Cray 于 1996 年因车祸受伤去世。在他去世时，这位 70 岁的计算机先驱正在为他的下一代超级计算机愿景而努力。（更多详情请访问 www.cray.com。）

1963年，第一台超级计算机的消息宣布了。这个消息既不是来自大公司，甚至也不是来自高科技中心。
西摩·克雷在明尼苏达州领导了控制数据公司 CDC 6600 的设计。
这台机器包含了许多在最新微处理器中开始出现的思想。
克雷后来离开 CDC，在威斯康星州成立了克雷研究公司。1976年，他宣布了 Cray-1（图 e1.12.4）。
这台机器同时是世界上最快的、最昂贵的，也是科学程序性价比最高的计算机。
当西摩·克雷在创造世界上最昂贵的计算机时，世界各地的其他设计师正在研究如何使用微处理器来创造一台如此便宜的计算机，以至于你可以在家里拥有一台。
个人计算机没有单一的源头，但在 1977 年，史蒂夫·乔布斯和史蒂夫·沃兹尼亚克的 Apple IIe（图 e1.12.5）为低成本、高产量和高可靠性设定了标准，定义了个人计算机行业。

\--- PAGE 86 ---

1.12 历史观点与延伸阅读
54.e7

**图 e1.12.5** Apple IIc Plus。由史蒂夫·沃兹尼亚克设计，Apple IIc 为行业设定了成本和可靠性标准。
然而，即使有 4 年的领先优势，苹果的个人电脑在受欢迎程度上也只排第二。
1981 年发布的 IBM 个人电脑成为任何类型中最畅销的电脑；
它的成功使英特尔拥有了最受欢迎的微处理器，微软拥有了最受欢迎的操作系统。
今天，最受欢迎的 CD 是微软的操作系统，尽管它的价格比一张音乐 CD 高出许多倍！
当然，在兼容 IBM 的个人电脑存在的 30 多年里，它已经有了很大的发展。
事实上，第一台个人电脑拥有 16 位处理器和 64 KB 内存，而低密度、慢速的软盘是唯一的非易失性存储！
**层次结构**
软盘最初由 IBM 为在大型机中加载诊断程序而开发，但在 CD 和网络出现之前，它作为个人电脑中交换数据的主要 I/O 设备存在了近 20 年，之后才被淘汰。
当然，自第一台使用 16 位处理器和 8 位外部接口的 PC 问世以来，英特尔微处理器也发生了演变！
在第 2 章中，我们写到了英特尔架构的演变。
第一代个人电脑相当简单，几乎没有图形能力，没有指针设备，操作系统与今天的相比也相当原始。
启发了现代台式机许多架构和软件概念的计算机是施乐奥托 (Xerox Alto)，如图 e1.12.6 所示。
奥托是作为未来计算机的实验原型而创造的；
共制造了数百台奥托，其中有相当一部分

\--- PAGE 87 ---

54.e8
1.12 历史观点与延伸阅读

**图 e1.12.6** 施乐奥托是现代台式机的主要灵感来源。它包括一个鼠标、一个位图显示、一个基于窗口的用户界面和一个本地网络连接。
捐赠给了大学。奥托所包含的技术有：
■ 与计算机集成的位图图形显示器（早期的图形显示器充当终端，通常连接到更大的计算机）
■ 鼠标，虽然是早先发明的，但每台奥托都配备了，并在用户界面中广泛使用
■ 局域网 (LAN)，它成为以太网的前身
■ 基于窗口的用户界面，具有所见即所得 (WYSIWYG) 编辑器和交互式绘图程序

\--- PAGE 88 ---

1.12 历史观点与延伸阅读
54.e9
此外，文件服务器和打印服务器都通过局域网开发和接口，局域网和广域 ARPAnet 之间的连接产生了互联网式网络的第一版。
施乐 Alto 影响深远，明显影响了各种计算机和软件系统的设计，包括苹果麦金塔、IBM 兼容 PC、MacOS 和 Windows，以及 Sun 和其他早期的工作站。
**衡量性能**
从计算的最初期开始，设计师们就设定了性能目标——ENIAC 要比哈佛 Mark-I 快 1000 倍，而 IBM Stretch (7030) 要比当时存在的最快的计算机快 100 倍。
然而，不清楚的是，这种性能将如何衡量。
最初的性能衡量标准是执行单个操作（如加法）所需的时间。
由于大多数指令的执行时间相同，所以一个指令的时间与其他指令相同。
然而，随着计算机中指令的执行时间变得更加多样化，一个操作所需的时间不再适用于比较。
为了考虑这些差异，通过测量计算机中许多程序中指令的相对频率来计算指令混合。
将每条指令的时间乘以其在混合中的权重，就得到了用户的平均指令执行时间。
（如果以时钟周期为单位，平均指令执行时间与平均 CPI 相同。）由于指令集相似，这比加法时间更精确。
从平均指令执行时间，到 MIPS 只有一小步。
MIPS 的优点是易于理解；因此，它越来越受欢迎。
**寻求一个平均程序**
随着处理器变得越来越复杂，并依赖于存储器层次结构（第 5 章的主题）和流水线（第 4 章的主题），每条指令的单一执行时间不再存在；
因此，执行时间或 MIPS 都无法从指令混合和手册中计算出来。
尽管今天看来，正确的做法本应是开发一套可作为标准基准的真实应用程序，但这在相对较近的时期之前是一项艰巨的任务。
操作系统和语言标准的变化使得创建可以简单地通过重新编译就从一台计算机移植到另一台计算机的大型程序变得困难。
相反，下一步是使用合成程序进行基准测试。
Whetstone 合成程序是通过测量用 Algol-60 编写的科学程序而创建的（参见 Curnow 和 Wichmann [1976] 的描述）。
这

\--- PAGE 89 ---

54.e10
1.12 历史观点与延伸阅读
这个程序被转换为 Fortran 语言，并被广泛用于表征科学程序的性能。
Whetstone 性能通常以每秒 Whetstones 为单位报价——即 Whetstone 基准测试单次迭代的执行次数！
Dhrystone 是另一个合成基准测试，在一些嵌入式计算领域仍在使用（参见 Weicker [1984] 的描述和方法）。
大约在 Whetstone 开发的同时，核心（kernel）基准测试的概念开始流行起来。
核心是从真实程序中提取的、耗时的小片段，然后用作基准。
这种方法主要是为基准测试高端计算机，特别是超级计算机而开发的。利弗莫尔循环（Livermore Loops）和 Linpack 是最著名的例子。
利弗莫尔循环由一系列 21 个小循环片段组成。
Linpack 包含一个线性代数子程序包的一部分。
核心最适合用来隔离计算机单个特性的性能，并解释真实程序性能差异的原因。
由于科学应用经常使用执行时间长的小段代码，用核心来表征性能在这一应用类别中最受欢迎。
尽管核心有助于阐明性能，但它们常常夸大真实应用程序的性能。
**关于性能的 SPEC 推测**
性能评估的一个重要进展是 1988 年系统性能评估合作组织（SPEC）的成立。SPEC 由多家计算机公司的代表组成——创始人是 Apollo/惠普、DEC、MIPS 和 Sun——他们就一套所有人都将运行的真实程序和输入达成了一致。
值得注意的是，在可移植操作系统和高级语言普及之前，SPEC 是不可能出现的。
现在，编译器也被认为是计算机系统性能的应有组成部分，必须在任何评估中进行测量。
历史告诉我们，虽然 SPEC 的努力对当前的计算机可能有用，但如果不改变，它将无法满足下一代的需求。
1991年，增加了一项吞吐量度量，基于运行基准测试的多个版本。
它对于评估单处理器或多处理器的时间共享使用最为有用。
其他系统基准测试，包括操作系统密集型和 I/O 密集型活动，也已被添加。
另一个变化是决定放弃一些基准测试并增加其他基准测试。
寻找基准测试的困难导致 SPEC 基准测试的初始版本（称为 SPEC89）包含六个浮点基准测试，但只有四个整数基准测试。
使用执行时间归一化到 VAX-11/780 的几何平均值来计算单个摘要度量，意味着该度量偏爱具有强大浮点性能的计算机。

\--- PAGE 90 ---

1.12 历史观点与延伸阅读
54.e11
1992年，引入了一套新的基准测试（称为 SPEC92）。
它包含了额外的基准测试，放弃了 matrix300，并为整数和浮点程序提供了单独的平均值（SPEC INT 和 SPECFP）。
此外，还增加了 SPECbase 测量，该测量不允许使用特定于程序的优化标志，以便为用户提供一个更接近他们自己程序上可能体验到的性能测量。
SPECFP 数值相对于基础 SPECFP 测量值增幅最大，通常高出 15% 到 30%。
1995 年，基准测试集再次更新，增加了一些新的整数和浮点基准测试，同时移除了一些存在缺陷或运行时间因自首次 SPEC 发布以来性能提升 20 倍或更多而变得过短的基准测试。
SPEC95 还将归一化的基准计算机更改为 Sun SPARC Station 10/40，因为原始基准计算机的运行版本越来越难找到！
SPEC 的最新版本是 SPEC2006。也许最令人惊讶的是，SPEC2006 中的所有浮点程序都是新的，而对于整数程序，只有两个来自 SPEC2000，一个来自 SPEC95，没有来自 SPEC92，一个来自 SPEC89。
从 SPEC89 幸存下来的唯一一个是 gcc 编译器。
SPEC 还增加了超出最初针对 CPU 性能的套件的基准测试套件。
2008年，SPEC 提供了用于图形、高性能科学计算、面向对象计算、文件系统、Web 服务器和客户端、Java、工程 CAD 应用和功率的基准测试集。
**嵌入式计算的增长**
嵌入式处理器已经存在很长时间了；
事实上，第一台小型计算机和第一台微处理器最初是为控制实验室或工业应用中的功能而开发的。
多年来，嵌入式处理器的主要用途是工业控制应用，尽管这种用途持续增长，但处理器往往非常便宜，性能相对较低。
例如，世界上销量最好的处理器仍然是用于汽车、一些家用电器和其他简单应用的 8 位微控制器。
20 世纪 80 年代末和 90 年代初，嵌入式处理器出现了新的机遇，从更先进的视频游戏和机顶盒到手机和个人数字助理。
信息家电数量的迅速增加和网络的增长，推动了嵌入式处理器数量以及性能需求的急剧增长。
为了评估性能，嵌入式社区受到 SPEC 的启发，创建了嵌入式微处理器基准测试联盟 (EEMBC)。
该联盟始于 1997 年，由一系列核心程序组成，这些核心程序被组织成针对嵌入式行业不同部分的套件。
他们在 2007 年宣布了这些基准测试的第二代。

\--- PAGE 91 ---

54.e12
1.12 历史观点与延伸阅读
**摩尔定律**
**半个世纪的进步**
自 1951 年以来，已经有数千种使用各种技术、能力迥异的新计算机。
图 e1.12.7 总结了本节中提到的一些机器的关键特性，并显示了在短短 50 多年里发生的巨大变化。
经通货膨胀调整后，性价比在 55 年内提高了近 1000 亿倍，即每年约 58%。
换句话说，我们在成本上看到了 10,000 倍的改进，在性能上看到了 10,000,000 倍的改进。

| 年份 | 名称 | 尺寸 (立方英尺) | 功率 (瓦特) | 性能 (加法/秒) | 内存 (KB) | 价格 | 价格/性能 vs. UNIVAC | 调整后价格 (2007 $) | 调整后价格/性能 vs. UNIVAC |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1951 | UNIVAC I | 1000 | 125,000 | 2,000 | 48 | $1,000,000 | 1 | $7,670,724 | 1 |
| 1964 | IBM S/360 model 50 | 60 | 10,000 | 500,000 | 64 | $1,000,000 | 263 | $6,018,798 | 319 |
| 1965 | PDP-8 | 8 | 500 | 330,000 | 4 | $16,000 | 10,855 | $94,685 | 13,367 |
| 1976 | Cray-1 | 58 | 60,000 | 166,000,000 | 32,000 | $4,000,000 | 21,842 | $13,509,798 | 47,127 |
| 1981 | IBM PC | 1 | 150 | 240,000 | 256 | $3,000 | 42,105 | $6,859 | 134,208 |
| 1991 | HP 9000/model 750 | 2 | 500 | 50,000,000 | 16,384 | $7,400 | 3,556,188 | $11,807 | 16,241,889 |
| 1996 | Intel PPro PC (200 MHz) | 2 | 500 | 400,000,000 | 16,384 | $4,400 | 47,846,890 | $6,211 | 247,021,234 |
| 2003 | Intel Pentium 4 PC (3.0 GHz) | 2 | 500 | 6,000,000,000 | 262,144 | $1,600 | 1,875,000,000 | $2,009 | 11,451,750,000 |
| 2007 | AMD Barcelona PC (2.5 GHz) | 2 | 250 | 20,000,000,000 | 2,097,152 | $800 | 12,500,000,000 | $800 | 95,884,051,042 |

**图 e1.12.7** 自 1950 年以来关键商用计算机的特性，以实际美元和经通货膨胀调整的 2007 年美元计。最后一行假设我们可以充分利用巴塞罗那四个核心的潜在性能。与图 e1.12.3 相反，这里 IBM S/360 model 50 的价格包括了 I/O 设备。(来源：计算机历史博物馆和工业商品生产者价格指数。)
对计算机历史感兴趣的读者应查阅《计算史年鉴》，这是一本专门研究计算历史的期刊。
几本描述计算早期的书籍也已出版，许多由先驱者撰写，包括 Goldstine [1972]、Metropolis 等人 [1980] 和 Wilkes [1985]。

-----

以上是第 72-91 页的翻译。请您先复制或导出。

完成后，请告诉我，我们是否要继续翻译最后一部分（第 92-100 页）？好的，这是最后一部分了。


包含 **第 92 页到第 100 页** 的翻译内容。

-----

\--- PAGE 92 ---

1.12 历史观点与延伸阅读
54.e13
**延伸阅读**
Barroso, L. and U. Hölzle [2007]. "The case for energy-proportional computing", IEEE Computer December.
呼吁改变计算机组件的性质，使其在轻度使用时功耗大大降低。
Bell, C. G. [1996]. Computer Pioneers and Pioneer Computers, ACM and the Computer Museum, videotapes.
两盘关于计算历史的录像带，由 Gordon 和 Gwen Bell 制作，包括以下机器及其发明者：Harvard Mark-I、ENIAC、EDSAC、IAS machine 等。
Burks, A. W., H. H. Goldstine, and J. von Neumann [1946]. "Preliminary discussion of the logical design of an electronic computing instrument," Report to the U.S. Army Ordnance Department, p. 1;
also appears in Papers of John von Neumann, W. Aspray and A. Burks (Eds.), MIT Press, Cambridge, MA, and Tomash Publishers, Los Angeles, 1987, 97-146.
一篇在第一台存储程序计算机建成之前解释计算机硬件和软件的经典论文。我们在第 3 章中广泛引用了它。它同时向世界解释了计算机，也因初稿未给予 Eckert 和 Mauchly 应有的荣誉而成为争议之源。
Campbell-Kelly, M. and W. Aspray [1996]. Computer: A History of the Information Machine, Basic Books, New York.
两位历史学家记录了这个戏剧性的故事。《纽约时报》称其文笔优美、权威。
Ceruzzi, P. F. (1998). A History of Modern Computing, MIT Press, Cambridge, MA.
详细描述了计算后期历史：集成电路及其影响、个人电脑、UNIX 和互联网。
Curnow, H. J. and B. A. Wichmann [1976]. "A synthetic benchmark", The Computer J. 19(1):80.
描述了第一个主要的合成基准 Whetstone 以及它是如何被创造出来的。
Flemming, P. J. and J. J. Wallace [1986]. "How not to lie with statistics: The correct way to summarize benchmark results", Comm. ACM 29:3 (March), 218-21.
描述了使用不同平均值总结性能结果的一些基本原则。
Goldstine, H. H. [1972]. The Computer: From Pascal to von Neumann, Princeton University Press. Princeton, NJ.
一位与冯·诺依曼共事的先驱者对计算的个人看法。
Hayes, B. [2007]. "Computing in a parallel universe". American Scientist Vol. 95(November-December):476-480.
一篇为外行撰写的并行计算挑战概述。
Hennessy, J. L. and D. A. Patterson [2007]. Chapter 1 of Computer Architecture: A Quantitative Approach, fourth edition, Morgan Kaufmann Publishers, San Francisco.
第 1.5 节更详细地讨论了功耗，第 1.6 节包含更多关于集成电路成本的细节，并解释了价格与成本之间的差异原因，第 1.8 节给出了更多关于评估性能的细节。
Lampson, B. W. [1986]. "Personal distributed computing: The Alto and Ethernet software." In ACM Conference on the History of Personal Workstations (January).

\--- PAGE 93 ---

54.e14
1.12 历史观点与延伸阅读
Thacker, C. R. [1986]. "Personal distributed computing: The Alto and Ethernet hardware," In ACM Conference on the History of Personal Workstations (January).
这两篇论文描述了具有里程碑意义的 Alto 的软件和硬件。
Metropolis, N., J. Howlett, and G.-C. Rota (Eds.) [1980]. A History of Computing in the Twentieth Century, Academic Press, New York.
一系列文章的集合，描述了参与第一批实验性和商用计算机的人员、软件、计算机和实验室。大多数作者都亲身参与了这些项目。这本有趣的书以一份优秀的早期报告参考书目作结。
Public Broadcasting System [1992]. The Machine That Changed the World, videotapes.
这五个时长 1 小时的节目包括珍贵的影像资料和对计算机行业先驱的采访。
Slater, R. [1987]. Portraits in Silicon, MIT Press, Cambridge, MA.
31 位计算机先驱的简短传记。
Stern, N. [1980]. "Who invented the first electronic digital computer?" Annals of the History of Computing 2:4 (October), 375-76.
一位历史学家对 Atanasoff 与 Eckert 和 Mauchly 之争的看法。
Weicker, R. P. [1984]. "Dhrystone: a synthetic systems programming benchmark", Communications of the ACM 27(10):1013-1030.
对一个用于系统代码的合成基准测试程序的描述。
Wilkes, M. V. [1985]. Memoirs of a Computer Pioneer, MIT Press, Cambridge, MA.
一位先驱者对计算的个人看法。

\--- PAGE 94 ---

1.13 练习
55
e. 图书馆预留台
f. 增加 CMOS 晶体管的栅极面积以减少其开关时间
g. 增加电磁飞机弹射器（与当前蒸汽动力型号相对，为电力驱动），这是由新技术反应堆提供的增加的发电能力所允许的
h. 构建自动驾驶汽车，其控制系统部分依赖于已安装在基础车辆中的现有传感器系统，如车道偏离系统和智能巡航控制系统
1.3 [2] \<§1.3\> 描述将用 C 等高级语言编写的程序转换为可由计算机处理器直接执行的表示形式的步骤。
1.4 [2] \<§1.4\> 假设一个彩色显示器每个像素使用 8 位表示三种原色（红、绿、蓝），帧大小为 $1280 \\times 1024$。
a. 存储一帧所需的帧缓冲区的最小尺寸（以字节为单位）是多少？
b. 通过 100 Mbit/s 的网络发送该帧至少需要多长时间？
1.5 [4] \<§1.6\> 考虑三个执行相同指令集的不同处理器 P1、P2 和 P3。
P1 的时钟频率为 3 GHz，CPI 为 1.5。
P2 的时钟频率为 2.5 GHz，CPI 为 1.0。
P3 的时钟频率为 4.0 GHz，CPI 为 2.2。
a. 哪个处理器以每秒指令数表示的性能最高？
b. 如果每个处理器都在 10 秒内执行一个程序，求出周期数和指令数。
c. 我们试图将执行时间减少 30%，但这导致 CPI 增加了 20%。我们应该设定什么样的时钟频率才能达到这个时间缩减？
1.6 [20] \<§1.6\> 考虑同一指令集架构的两种不同实现。
指令可根据其 CPI 分为四类（A、B、C 和 D）。
P1 的时钟频率为 2.5 GHz，CPI 分别为 1、2、3 和 3；P2 的时钟频率为 3 GHz，CPI 分别为 2、2、2 和 2。
给定一个动态指令数为 1.0E6 的程序，其指令分类如下：10% A 类，20% B 类，50% C 类，20% D 类，P1 和 P2 哪个更快？
a. 每个实现的全局 CPI 是多少？
b. 求出两种情况下所需的时钟周期数。

\--- PAGE 95 ---

56
第 1 章 计算机抽象与技术
1.7 [15] \<§1.6\> 编译器可以对应用程序的性能产生深远的影响。
假设对于一个程序，编译器 A 产生的动态指令数为 1.0E9，执行时间为 1.1 秒；而编译器 B 产生的动态指令数为 1.2E9，执行时间为 1.5 秒。
a. 假设处理器时钟周期为 1 纳秒，求出每个程序的平均 CPI。
b. 假设编译后的程序在两个不同的处理器上运行。
如果两个处理器上的执行时间相同，运行编译器 A 代码的处理器时钟比运行编译器 B 代码的处理器时钟快多少？
c. 开发了一款新编译器，只使用 6.0E8 条指令，平均 CPI 为 1.1。
在原始处理器上，使用这款新编译器相比使用编译器 A 或 B 的加速比是多少？
1.8 2004 年发布的奔腾 4 Prescott 处理器，时钟频率为 3.6 GHz，电压为 1.25 V。假设它平均消耗 10 W 的静态功耗和 90 W 的动态功耗。
2012 年发布的酷睿 i5 Ivy Bridge，时钟频率为 3.4 GHz，电压为 0.9 V。假设它平均消耗 30 W 的静态功耗和 40 W 的动态功耗。
1.8.1 [5] \<§1.7\> 求出每个处理器的平均电容负载。
1.8.2 [5] \<§1.7\> 求出每种技术中静态功耗占总耗散功率的百分比，以及静态功耗与动态功耗的比率。
1.8.3 [15] \<§1.7\> 如果要将总耗散功率降低 10%，在保持相同泄漏电流的情况下，电压应降低多少？
注意：功率定义为电压和电流的乘积。
1.9 假设对于算术、加载/存储和分支指令，一个处理器的 CPI 分别为 1、12 和 5。
还假设在单个处理器上，一个程序需要执行 2.56E9 条算术指令、1.28E9 条加载/存储指令和 2.56 亿条分支指令。
假设每个处理器的时钟频率为 2 GHz。
假设，当程序并行化以在多个核心上运行时，每个处理器的算术和加载/存储指令数除以 $0.7 \\times p$（其中 p 是处理器数量），但每个处理器的分支指令数保持不变。
1.9.1 [5] \<§1.7\> 求出该程序在 1、2、4 和 8 个处理器上的总执行时间，并显示 2、4 和 8 个处理器结果相对于单个处理器结果的相对加速比。

\--- PAGE 96 ---

1.13 练习
1.9.2 [10] \<§§1.6, 1.8\> 如果算术指令的 CPI 翻倍，对程序在 1、2、4 或 8 个处理器上的执行时间会有什么影响？
1.9.3 [10] \<§§1.6, 1.8\> 为了使单个处理器能够匹配使用原始 CPI 值的四个处理器的性能，加载/存储指令的 CPI 应该降低到多少？
1.10 假设一个直径 15 厘米的晶圆成本为 12，包含 84 个晶粒，缺陷率为 0.020 缺陷/平方厘米。
假设一个直径 20 厘米的晶圆成本为 15，包含 100 个晶粒，缺陷率为 0.031 缺陷/平方厘米。
1.10.1 [10] \<§1.5\> 求出两个晶圆的良率。
1.10.2 [5] \<§1.5\> 求出两个晶圆的单位晶粒成本。
1.10.3 [5] \<§1.5\> 如果每个晶圆的晶粒数量增加 10%，单位面积的缺陷数增加 15%，求出晶粒面积和良率。
1.10.4 [5] \<§1.5\> 假设一个制造工艺将良率从 0.92 提高到 0.95。
给定晶粒面积为 200 平方毫米，求出每种技术版本的单位面积缺陷数。
1.11 SPEC CPU2006 bzip2 基准测试在 AMD Barcelona 上运行的结果是：指令数为 2.389E12，执行时间为 750 秒，参考时间为 9650 秒。
1.11.1 [5] \<§§1.6, 1.9\> 如果时钟周期时间是 0.333 纳秒，求 CPI。
1.11.2 [5] \<§1.9\> 求 SPECratio。
1.11.3 [5] \<§§1.6, 1.9\> 如果基准测试的指令数增加 10% 而不影响 CPI，CPU 时间会增加多少？
1.11.4 [5] \<§§1.6, 1.9\> 如果基准测试的指令数增加 10% 且 CPI 增加 5%，CPU 时间会增加多少？
1.11.5 [5] \<§§1.6, 1.9\> 求出这种变化对 SPECratio 的影响。
1.11.6 [10] \<§1.6\> 假设我们正在开发一个新版本的 AMD Barcelona 处理器，时钟频率为 4GHz。
我们在指令集中增加了一些额外的指令，使得指令数减少了 15%。
执行时间减少到 700 秒，新的 SPECratio 是 13.7。求新的 CPI。
1.11.7 [10] \<§1.6\> 这个 CPI 值比 1.11.1 中获得的值要大，因为时钟频率从 3 GHz 增加到 4 GHz。
判断 CPI 的增加是否与时钟频率的增加相似。如果它们不相似，为什么？
1.11.8 [5] \<§1.6\> CPU 时间减少了多少？
57

\--- PAGE 97 ---

58
第 1 章 计算机抽象与技术
1.11.9 [10] \<§1.6\> 对于第二个基准测试 libquantum，假设执行时间为 960 纳秒，CPI 为 1.61，时钟频率为 3 GHz。
如果在不影响 CPI 且时钟频率为 4 GHz 的情况下，执行时间再减少 10%，求指令数。
1.11.10 [10] \<§1.6\> 在保持指令数不变且 CPI 不变的情况下，要使 CPU 时间再减少 10%，需要多高的时钟频率？
1.11.11 [10] \<§1.6\> 如果 CPI 减少 15%，CPU 时间减少 20%，而指令数不变，求时钟频率。
1.12 第 1.10 节将使用性能方程的一个子集作为性能指标的做法列为一个陷阱。
为了说明这一点，考虑以下两个处理器。P1 的时钟频率为 4 GHz，平均 CPI 为 0.9，需要执行 5.0E9 条指令。
P2 的时钟频率为 3 GHz，平均 CPI 为 0.75，需要执行 1.0E9 条指令。
1.12.1 [5] \<§§1.6, 1.10\> 一个常见的谬误是认为时钟频率最高的计算机性能最高。
检查这对于 P1 和 P2 是否成立。
1.12.2 [10] \<§§1.6, 1.10\> 另一个谬误是认为执行最多指令的处理器需要更长的 CPU 时间。
考虑到处理器 P1 正在执行一个 1.0E9 指令的序列，并且处理器 P1 和 P2 的 CPI 不变，确定 P2 在 P1 需要执行 1.0E9 指令的相同时间内可以执行多少条指令。
1.12.3 [10] \<§§1.6, 1.10\> 一个常见的谬误是使用 MIPS（每秒百万条指令）来比较两个不同处理器的性能，并认为 MIPS 最大的处理器性能最高。
检查这对于 P1 和 P2 是否成立。
1.12.4 [10] \<§1.10\> 另一个常见的性能指标是 MFLOPS（每秒百万次浮点运算），定义为
$$\text{MFLOPS} = \frac{\text{浮点运算次数}}{(\text{执行时间} \times 1E6)}$$
但这个指标和 MIPS 有同样的问题。假设在 P1 和 P2 上执行的指令中有 40% 是浮点指令。
求出这两个处理器的 MFLOPS 指标。
1.13 第 1.10 节中引用的另一个陷阱是期望通过仅改进计算机的一个方面来提高计算机的整体性能。
考虑一台计算机运行一个需要 250 秒的程序，其中 70 秒用于执行 FP 指令，85 秒执行 L/S 指令，40 秒执行分支指令。
1.13.1 [5] \<§1.10\> 如果 FP 操作的时间减少 20%，总时间减少了多少？

\--- PAGE 98 ---

1.13 练习
59
1.13.2 [5] \<§1.10\> 如果总时间减少了 20%，INT 操作的时间减少了多少？
1.13.3 [5] \<§1.10\> 能否仅通过减少分支指令的时间将总时间减少 20%？
1.14 假设一个程序需要执行 $50 \\times 10^6$ 条 FP 指令、$110 \\times 10^6$ 条 INT 指令、$80 \\times 10^6$ 条 L/S 指令以及 $16 \\times 10^6$ 条分支指令。
每种指令的 CPI 分别为 1、1、4 和 2。
假设处理器的时钟频率为 2 GHz。
1.14.1 [10] \<§1.10\> 如果我们想让程序运行速度快两倍，FP 指令的 CPI 必须提高多少？
1.14.2 [10] \<§1.10\> 如果我们想让程序运行速度快两倍，L/S 指令的 CPI 必须提高多少？
1.14.3 [5] \<§1.10\> 如果 INT 和 FP 指令的 CPI 降低 40%，L/S 和分支指令的 CPI 降低 30%，程序的执行时间能改善多少？
1.15 [5] \<§1.8\> 当一个程序被调整为在多处理器系统的多个处理器上运行时，每个处理器上的执行时间由计算时间和用于锁定临界区和/或将数据从一个处理器发送到另一个处理器所需的开销时间组成。
假设一个程序在一个处理器上需要 $t=100$ 秒的执行时间。
当在 p 个处理器上运行时，每个处理器需要 $t/p$ 秒，以及额外的 4 秒开销，无论处理器数量多少。
计算 2、4、8、16、32、64 和 128 个处理器下每个处理器的执行时间。
对于每种情况，列出相对于单个处理器的相应加速比，以及实际加速比与理想加速比（如果没有开销时的加速比）之间的比率。
**自测题答案**
§1.1, page 10: 讨论题：许多答案都可以接受。
§1.4, page 24: DRAM 内存：易失性，访问时间短，为 50 到 70 纳秒，每 GB 成本为 5 到 10 美元。
磁盘内存：非易失性，访问时间比 DRAM 慢 10 万到 40 万倍，每 GB 成本比 DRAM 便宜 100 倍。
闪存：非易失性，访问时间比 DRAM 慢 100 到 1000 倍，每 GB 成本比 DRAM 便宜 7 到 10 倍。
§1.5, page 28: 1、3 和 4 是有效的原因。
答案 5 通常可以成立，因为大批量生产可以使额外投资（例如，将芯片尺寸减小 10%）成为一个好的经济决策，但它不一定总是成立。
§1.6, page 33: 1. a: 两者皆有, b: 延迟, c: 都不是。 7 秒。
§1.6, page 40: b。
§1.10, page 51: a. 计算机 A 的 MIPS 评级更高。 b. 计算机 B 更快。

\--- PAGE 99 ---

2
我对上帝说西班牙语，对女人说意大利语，对男人说法语，对我的马说德语。——查理五世，神圣罗马帝国皇帝（1500-1558）
**指令：**
**计算机的语言**

| | |
| :--- | :--- |
| 2.1 | 引言 62 |
| 2.2 | 计算机硬件的操作 63 |
| 2.3 | 计算机硬件的操作数 67 |
| 2.4 | 有符号数和无符号数 74 |
| 2.5 | 在计算机中表示指令 81 |
| 2.6 | 逻辑运算 89 |
| 2.7 | 用于做决策的指令 92 |

计算机组织与设计。 DOI: http://dx.doi.org/10.1016/8978-0-12-812275-4.00002-6
2018 Elsevier Inc. 版权所有

\--- PAGE 100 ---

| | |
| :--- | :--- |
| 2.8 | 在计算机硬件中支持过程 98 |
| 2.9 | 与人交流 108 |
| 2.10 | RISC-V 宽立即数和地址寻址 113 |
| 2.11 | 并行性与指令：同步 121 |
| 2.12 | 翻译并启动程序 124 |
| 2.13 | 一个 C 语言排序示例的综合应用 133 |
| 2.14 | 数组与指针 141 |
| 2.15 | 高级材料：编译 C 和解释 Java 144 |
| 2.16 | 实例：MIPS 指令 145 |
| 2.17 | 实例：x86 指令 146 |
| 2.18 | 实例：RISC-V 指令集的其余部分 155 |
| 2.19 | 谬误与陷阱 157 |
| 2.20 | 结论 159 |
| 2.21 | 历史观点与延伸阅读 162 |
| 2.22 | 练习 162 |

**计算机的五个经典组件**

-----

至此，全部 100 页的翻译内容都已提供给您。希望对您有帮助！